<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">{- Language/Haskell/TH/Desugar.hs

(c) Richard Eisenberg 2013
rae@cs.brynmawr.edu
-}</span><span>
</span><span id="line-6"></span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE CPP, MultiParamTypeClasses, FunctionalDependencies,
             TypeSynonymInstances, FlexibleInstances, LambdaCase #-}</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Module      :  Language.Haskell.TH.Desugar</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- Copyright   :  (C) 2014 Richard Eisenberg</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- License     :  BSD-style (see LICENSE)</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Maintainer  :  Ryan Scott</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Portability :  non-portable</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- Desugars full Template Haskell syntax into a smaller core syntax for further</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- processing.</span><span>
</span><span id="line-21"></span><span class="hs-comment">--</span><span>
</span><span id="line-22"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-23"></span><span>
</span><span id="line-24"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Desugar</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-25"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Desugared data types</span></span><span>
</span><span id="line-26"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier">DExp</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier">DLetDec</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier">DPat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier">DType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier">DKind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier">DCxt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPred"><span class="hs-identifier">DPred</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier">DTyVarBndr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier">DMatch</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier">DClause</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier">DDec</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivClause"><span class="hs-identifier">DDerivClause</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDerivStrategy"><span class="hs-identifier">DDerivStrategy</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynDir"><span class="hs-identifier">DPatSynDir</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPatSynType"><span class="hs-identifier">DPatSynType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>  </span><span class="annot"><span class="hs-identifier">Overlap</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">PatSynArgs</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#NewOrData"><span class="hs-identifier">NewOrData</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTypeFamilyHead"><span class="hs-identifier">DTypeFamilyHead</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFamilyResultSig"><span class="hs-identifier">DFamilyResultSig</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">InjectivityAnn</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier">DCon</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConFields"><span class="hs-identifier">DConFields</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDeclaredInfix"><span class="hs-identifier">DDeclaredInfix</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangType"><span class="hs-identifier">DBangType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarBangType"><span class="hs-identifier">DVarBangType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>  </span><span class="annot"><span class="hs-identifier">Bang</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">SourceUnpackedness</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">SourceStrictness</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DForeign"><span class="hs-identifier">DForeign</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPragma"><span class="hs-identifier">DPragma</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRuleBndr"><span class="hs-identifier">DRuleBndr</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTySynEqn"><span class="hs-identifier">DTySynEqn</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInfo"><span class="hs-identifier">DInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DInstanceDec"><span class="hs-identifier">DInstanceDec</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>  </span><span class="annot"><span class="hs-identifier">Role</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">AnnTarget</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span>  </span><span class="annot"><span class="hs-comment">-- * The 'Desugar' class</span></span><span>
</span><span id="line-38"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier">Desugar</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Main desugaring functions</span></span><span>
</span><span id="line-41"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsExp"><span class="hs-identifier">dsExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDecs"><span class="hs-identifier">dsDecs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsType"><span class="hs-identifier">dsType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsInfo"><span class="hs-identifier">dsInfo</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPatOverExp"><span class="hs-identifier">dsPatOverExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPatsOverExp"><span class="hs-identifier">dsPatsOverExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPatX"><span class="hs-identifier">dsPatX</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsLetDecs"><span class="hs-identifier">dsLetDecs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsTvb"><span class="hs-identifier">dsTvb</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsCxt"><span class="hs-identifier">dsCxt</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsCon"><span class="hs-identifier">dsCon</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsForeign"><span class="hs-identifier">dsForeign</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPragma"><span class="hs-identifier">dsPragma</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsRuleBndr"><span class="hs-identifier">dsRuleBndr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Secondary desugaring functions</span></span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#PatM"><span class="hs-identifier">PatM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPred"><span class="hs-identifier">dsPred</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPat"><span class="hs-identifier">dsPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDec"><span class="hs-identifier">dsDec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDataDec"><span class="hs-identifier">dsDataDec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDataInstDec"><span class="hs-identifier">dsDataInstDec</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#DerivingClause"><span class="hs-identifier">DerivingClause</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDerivClause"><span class="hs-identifier">dsDerivClause</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsLetDec"><span class="hs-identifier">dsLetDec</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-49"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsMatches"><span class="hs-identifier">dsMatches</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsBody"><span class="hs-identifier">dsBody</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsGuards"><span class="hs-identifier">dsGuards</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsDoStmts"><span class="hs-identifier">dsDoStmts</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsComp"><span class="hs-identifier">dsComp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsClauses"><span class="hs-identifier">dsClauses</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsBangType"><span class="hs-identifier">dsBangType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsVarBangType"><span class="hs-identifier">dsVarBangType</span></a></span><span class="hs-special">,</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt; 710
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsTypeFamilyHead"><span class="hs-identifier">dsTypeFamilyHead</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsFamilyResultSig"><span class="hs-identifier">dsFamilyResultSig</span></a></span><span class="hs-special">,</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 801
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsPatSynDir"><span class="hs-identifier">dsPatSynDir</span></a></span><span class="hs-special">,</span><span class="hs-cpp">
#endif
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsTypeArg"><span class="hs-identifier">dsTypeArg</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Converting desugared AST back to TH AST</span></span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Sweeten.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Sweeten</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Expanding type synonyms</span></span><span>
</span><span id="line-63"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Expand.html#expand"><span class="hs-identifier">expand</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Expand.html#expandType"><span class="hs-identifier">expandType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Reification</span></span><span>
</span><span id="line-66"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#reifyWithWarning"><span class="hs-identifier">reifyWithWarning</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-comment">-- | The following definitions allow you to register a list of</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-comment">-- @Dec@s to be used in reification queries.</span><span>
</span><span id="line-70"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#withLocalDeclarations"><span class="hs-identifier">withLocalDeclarations</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dsReify"><span class="hs-identifier">dsReify</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-71"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#reifyWithLocals_maybe"><span class="hs-identifier">reifyWithLocals_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#reifyWithLocals"><span class="hs-identifier">reifyWithLocals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#reifyFixityWithLocals"><span class="hs-identifier">reifyFixityWithLocals</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-72"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#lookupValueNameWithLocals"><span class="hs-identifier">lookupValueNameWithLocals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#lookupTypeNameWithLocals"><span class="hs-identifier">lookupTypeNameWithLocals</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-73"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#mkDataNameWithLocals"><span class="hs-identifier">mkDataNameWithLocals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#mkTypeNameWithLocals"><span class="hs-identifier">mkTypeNameWithLocals</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#reifyNameSpace"><span class="hs-identifier">reifyNameSpace</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-75"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsMonad"><span class="hs-identifier">DsMonad</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsM"><span class="hs-identifier">DsM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Nested pattern flattening</span></span><span>
</span><span id="line-78"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Match.html#scExp"><span class="hs-identifier">scExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Match.html#scLetDec"><span class="hs-identifier">scLetDec</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Capture-avoiding substitution and utilities</span></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Subst.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Subst</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Free variable calculation</span></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.FV.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.FV</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Utility functions</span></span><span>
</span><span id="line-87"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#applyDExp"><span class="hs-identifier">applyDExp</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-88"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dPatToDExp"><span class="hs-identifier">dPatToDExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#removeWilds"><span class="hs-identifier">removeWilds</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-89"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#getDataD"><span class="hs-identifier">getDataD</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#dataConNameToDataName"><span class="hs-identifier">dataConNameToDataName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#dataConNameToCon"><span class="hs-identifier">dataConNameToCon</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-90"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#nameOccursIn"><span class="hs-identifier">nameOccursIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#allNamesIn"><span class="hs-identifier">allNamesIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#flattenDValD"><span class="hs-identifier">flattenDValD</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#getRecordSelectors"><span class="hs-identifier">getRecordSelectors</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkTypeName"><span class="hs-identifier">mkTypeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkDataName"><span class="hs-identifier">mkDataName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier">newUniqueName</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-92"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#mkTupleDExp"><span class="hs-identifier">mkTupleDExp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#mkTupleDPat"><span class="hs-identifier">mkTupleDPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#maybeDLetE"><span class="hs-identifier">maybeDLetE</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#maybeDCaseE"><span class="hs-identifier">maybeDCaseE</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#mkDLamEFromDPats"><span class="hs-identifier">mkDLamEFromDPats</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-93"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleDegree_maybe"><span class="hs-identifier">tupleDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleNameDegree_maybe"><span class="hs-identifier">tupleNameDegree_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-94"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumDegree_maybe"><span class="hs-identifier">unboxedSumDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumNameDegree_maybe"><span class="hs-identifier">unboxedSumNameDegree_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-95"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleDegree_maybe"><span class="hs-identifier">unboxedTupleDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleNameDegree_maybe"><span class="hs-identifier">unboxedTupleNameDegree_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-96"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#strictToBang"><span class="hs-identifier">strictToBang</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isTypeKindName"><span class="hs-identifier">isTypeKindName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#typeKindName"><span class="hs-identifier">typeKindName</span></a></span><span class="hs-special">,</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#bindIP"><span class="hs-identifier">bindIP</span></a></span><span class="hs-special">,</span><span class="hs-cpp">
#endif
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#unravel"><span class="hs-identifier">unravel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#conExistentialTvbs"><span class="hs-identifier">conExistentialTvbs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#mkExtraDKindBinders"><span class="hs-identifier">mkExtraDKindBinders</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-101"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#dTyVarBndrToDType"><span class="hs-identifier">dTyVarBndrToDType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#toposortTyVarsOf"><span class="hs-identifier">toposortTyVarsOf</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** 'TypeArg'</span></span><span>
</span><span id="line-104"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier">TypeArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#applyType"><span class="hs-identifier">applyType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#filterTANormals"><span class="hs-identifier">filterTANormals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unfoldType"><span class="hs-identifier">unfoldType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** 'DTypeArg'</span></span><span>
</span><span id="line-107"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#DTypeArg"><span class="hs-identifier">DTypeArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#applyDType"><span class="hs-identifier">applyDType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#filterDTANormals"><span class="hs-identifier">filterDTANormals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#unfoldDType"><span class="hs-identifier">unfoldDType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Extracting bound names</span></span><span>
</span><span id="line-110"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier">extractBoundNamesStmt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier">extractBoundNamesDec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier">extractBoundNamesPat</span></a></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.AST</span></a></span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Core</span></a></span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Expand.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Expand</span></a></span><span>
</span><span id="line-116"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.FV.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.FV</span></a></span><span>
</span><span id="line-117"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Match.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Match</span></a></span><span>
</span><span id="line-118"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.OSet</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">OS</span></span><span>
</span><span id="line-119"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Reify</span></a></span><span>
</span><span id="line-120"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Subst.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Subst</span></a></span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Sweeten.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Sweeten</span></a></span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.Util</span></a></span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-126"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">F</span></span><span>
</span><span id="line-127"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span>
</span><span id="line-128"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span>
</span><span id="line-129"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-130"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-131"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">exp</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="hs-comment">-- | This class relates a TH type with its th-desugar type and allows</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- conversions back and forth. The functional dependency goes only one</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- way because `Type` and `Kind` are type synonyms, but they desugar</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- to different types.</span><span>
</span><span id="line-137"></span><span class="hs-keyword">class</span><span> </span><span id="Desugar"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-var">Desugar</span></a></span></span><span> </span><span id="local-6989586621679415835"><span class="annot"><a href="#local-6989586621679415835"><span class="hs-identifier hs-type">th</span></a></span></span><span> </span><span id="local-6989586621679415834"><span class="annot"><a href="#local-6989586621679415834"><span class="hs-identifier hs-type">ds</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679415834"><span class="hs-identifier hs-type">ds</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415835"><span class="hs-identifier hs-type">th</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-138"></span><span>  </span><span id="local-6989586621679415838"><span id="desugar"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#desugar"><span class="hs-identifier hs-type">desugar</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsMonad"><span class="hs-identifier hs-type">DsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679415838"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415835"><span class="hs-identifier hs-type">th</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415838"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679415834"><span class="hs-identifier hs-type">ds</span></a></span></span><span>
</span><span id="line-139"></span><span>  </span><span id="sweeten"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#sweeten"><span class="hs-identifier hs-type">sweeten</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679415834"><span class="hs-identifier hs-type">ds</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415835"><span class="hs-identifier hs-type">th</span></a></span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DExp"><span class="hs-identifier hs-type">DExp</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-142"></span><span>  </span><span id="local-6989586621679415611"><span class="annot"><span class="annottext">desugar :: Exp -&gt; q DExp
</span><a href="#local-6989586621679415611"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Exp -&gt; q DExp
forall (q :: * -&gt; *). DsMonad q =&gt; Exp -&gt; q DExp
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsExp"><span class="hs-identifier hs-var">dsExp</span></a></span><span>
</span><span id="line-143"></span><span>  </span><span id="local-6989586621679415610"><span class="annot"><span class="annottext">sweeten :: DExp -&gt; Exp
</span><a href="#local-6989586621679415610"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DExp -&gt; Exp
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#expToTH"><span class="hs-identifier hs-var">expToTH</span></a></span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-146"></span><span>  </span><span id="local-6989586621679415606"><span class="annot"><span class="annottext">desugar :: Type -&gt; q DType
</span><a href="#local-6989586621679415606"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; q DType
forall (q :: * -&gt; *). DsMonad q =&gt; Type -&gt; q DType
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsType"><span class="hs-identifier hs-var">dsType</span></a></span><span>
</span><span id="line-147"></span><span>  </span><span id="local-6989586621679415605"><span class="annot"><span class="annottext">sweeten :: DType -&gt; Type
</span><a href="#local-6989586621679415605"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DType -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#typeToTH"><span class="hs-identifier hs-var">typeToTH</span></a></span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCxt"><span class="hs-identifier hs-type">DCxt</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-150"></span><span>  </span><span id="local-6989586621679415601"><span class="annot"><span class="annottext">desugar :: Cxt -&gt; q DCxt
</span><a href="#local-6989586621679415601"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; q DCxt
forall (q :: * -&gt; *). DsMonad q =&gt; Cxt -&gt; q DCxt
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsCxt"><span class="hs-identifier hs-var">dsCxt</span></a></span><span>
</span><span id="line-151"></span><span>  </span><span id="local-6989586621679415600"><span class="annot"><span class="annottext">sweeten :: DCxt -&gt; Cxt
</span><a href="#local-6989586621679415600"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DCxt -&gt; Cxt
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#cxtToTH"><span class="hs-identifier hs-var">cxtToTH</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-154"></span><span>  </span><span id="local-6989586621679415596"><span class="annot"><span class="annottext">desugar :: TyVarBndr -&gt; q DTyVarBndr
</span><a href="#local-6989586621679415596"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; q DTyVarBndr
forall (q :: * -&gt; *). DsMonad q =&gt; TyVarBndr -&gt; q DTyVarBndr
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsTvb"><span class="hs-identifier hs-var">dsTvb</span></a></span><span>
</span><span id="line-155"></span><span>  </span><span id="local-6989586621679415595"><span class="annot"><span class="annottext">sweeten :: DTyVarBndr -&gt; TyVarBndr
</span><a href="#local-6989586621679415595"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DTyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#tvbToTH"><span class="hs-identifier hs-var">tvbToTH</span></a></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DDec"><span class="hs-identifier hs-type">DDec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-158"></span><span>  </span><span id="local-6989586621679415591"><span class="annot"><span class="annottext">desugar :: [Dec] -&gt; q [DDec]
</span><a href="#local-6989586621679415591"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Dec] -&gt; q [DDec]
forall (q :: * -&gt; *). DsMonad q =&gt; [Dec] -&gt; q [DDec]
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsDecs"><span class="hs-identifier hs-var">dsDecs</span></a></span><span>
</span><span id="line-159"></span><span>  </span><span id="local-6989586621679415590"><span class="annot"><span class="annottext">sweeten :: [DDec] -&gt; [Dec]
</span><a href="#local-6989586621679415590"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DDec] -&gt; [Dec]
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#decsToTH"><span class="hs-identifier hs-var">decsToTH</span></a></span><span>
</span><span id="line-160"></span><span>
</span><span id="line-161"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#Desugar"><span class="hs-identifier hs-type">Desugar</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Core.html#DTypeArg"><span class="hs-identifier hs-type">DTypeArg</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621679415586"><span class="annot"><span class="annottext">desugar :: TypeArg -&gt; q DTypeArg
</span><a href="#local-6989586621679415586"><span class="hs-identifier hs-var hs-var hs-var hs-var">desugar</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; q DTypeArg
forall (q :: * -&gt; *). DsMonad q =&gt; TypeArg -&gt; q DTypeArg
</span><a href="Language.Haskell.TH.Desugar.Core.html#dsTypeArg"><span class="hs-identifier hs-var">dsTypeArg</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span id="local-6989586621679415585"><span class="annot"><span class="annottext">sweeten :: DTypeArg -&gt; TypeArg
</span><a href="#local-6989586621679415585"><span class="hs-identifier hs-var hs-var hs-var hs-var">sweeten</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DTypeArg -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Sweeten.html#typeArgToTH"><span class="hs-identifier hs-var">typeArgToTH</span></a></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- | If the declaration passed in is a 'DValD', creates new, equivalent</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- declarations such that the 'DPat' in all 'DValD's is just a plain</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- 'DVarPa'. Other declarations are passed through unchanged.</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- Note that the declarations that come out of this function are rather</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- less efficient than those that come in: they have many more pattern</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- matches.</span><span>
</span><span id="line-171"></span><span id="local-6989586621679415583"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#flattenDValD"><span class="hs-identifier hs-type">flattenDValD</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679415583"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415583"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-172"></span><span id="flattenDValD"><span class="annot"><span class="annottext">flattenDValD :: DLetDec -&gt; q [DLetDec]
</span><a href="Language.Haskell.TH.Desugar.html#flattenDValD"><span class="hs-identifier hs-var hs-var">flattenDValD</span></a></span></span><span> </span><span id="local-6989586621679415582"><span class="annot"><span class="annottext">dec :: DLetDec
</span><a href="#local-6989586621679415582"><span class="hs-identifier hs-var">dec</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-type">DValD</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-type">DVarP</span></a></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DLetDec] -&gt; q [DLetDec]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415582"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-173"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#flattenDValD"><span class="hs-identifier hs-var">flattenDValD</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-type">DValD</span></a></span><span> </span><span id="local-6989586621679415579"><span class="annot"><span class="annottext">pat :: DPat
</span><a href="#local-6989586621679415579"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621679415578"><span class="annot"><span class="annottext">exp :: DExp
</span><a href="#local-6989586621679415578"><span class="hs-identifier hs-var">exp</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-174"></span><span>  </span><span id="local-6989586621679415577"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415577"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; q Name
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier hs-var">newUniqueName</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;x&quot;</span></span><span> </span><span class="hs-comment">-- must use newUniqueName here because we might be top-level</span><span>
</span><span id="line-175"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679415576"><span class="annot"><span class="annottext">top_val_d :: DLetDec
</span><a href="#local-6989586621679415576"><span class="hs-identifier hs-var hs-var">top_val_d</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DExp -&gt; DLetDec
</span><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-var">DValD</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415577"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621679415578"><span class="hs-identifier hs-var">exp</span></a></span><span>
</span><span id="line-176"></span><span>      </span><span id="local-6989586621679415575"><span class="annot"><span class="annottext">bound_names :: [Name]
</span><a href="#local-6989586621679415575"><span class="hs-identifier hs-var hs-var">bound_names</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; [Name]
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">F.toList</span></span><span> </span><span class="annot"><span class="annottext">(OSet Name -&gt; [Name]) -&gt; OSet Name -&gt; [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DPat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.FV.html#extractBoundNamesDPat"><span class="hs-identifier hs-var">extractBoundNamesDPat</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415579"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-177"></span><span>  </span><span id="local-6989586621679415572"><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415572"><span class="hs-identifier hs-var">other_val_ds</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; q DLetDec) -&gt; [Name] -&gt; q [DLetDec]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; q DLetDec
forall (m :: * -&gt; *). Quasi m =&gt; Name -&gt; Name -&gt; m DLetDec
</span><a href="#local-6989586621679415570"><span class="hs-identifier hs-var">mk_val_d</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415577"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679415575"><span class="hs-identifier hs-var">bound_names</span></a></span><span>
</span><span id="line-178"></span><span>  </span><span class="annot"><span class="annottext">[DLetDec] -&gt; q [DLetDec]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([DLetDec] -&gt; q [DLetDec]) -&gt; [DLetDec] -&gt; q [DLetDec]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415576"><span class="hs-identifier hs-var">top_val_d</span></a></span><span> </span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415572"><span class="hs-identifier hs-var">other_val_ds</span></a></span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-180"></span><span>    </span><span id="local-6989586621679415570"><span class="annot"><span class="annottext">mk_val_d :: Name -&gt; Name -&gt; m DLetDec
</span><a href="#local-6989586621679415570"><span class="hs-identifier hs-var hs-var">mk_val_d</span></a></span></span><span> </span><span id="local-6989586621679415569"><span class="annot"><span class="annottext">x :: Name
</span><a href="#local-6989586621679415569"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679415568"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679415568"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-181"></span><span>      </span><span id="local-6989586621679415567"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415567"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; m Name
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier hs-var">newUniqueName</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;y&quot;</span></span><span>
</span><span id="line-182"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679415566"><span class="annot"><span class="annottext">pat' :: DPat
</span><a href="#local-6989586621679415566"><span class="hs-identifier hs-var hs-var">pat'</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var">wildify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415568"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415567"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415579"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-183"></span><span>          </span><span id="local-6989586621679415564"><span class="annot"><span class="annottext">match :: DMatch
</span><a href="#local-6989586621679415564"><span class="hs-identifier hs-var hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DExp -&gt; DMatch
</span><a href="Language.Haskell.TH.Desugar.AST.html#DMatch"><span class="hs-identifier hs-var">DMatch</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415566"><span class="hs-identifier hs-var">pat'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DExp
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarE"><span class="hs-identifier hs-var">DVarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415567"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-184"></span><span>          </span><span id="local-6989586621679415561"><span class="annot"><span class="annottext">cas :: DExp
</span><a href="#local-6989586621679415561"><span class="hs-identifier hs-var hs-var">cas</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DExp -&gt; [DMatch] -&gt; DExp
</span><a href="Language.Haskell.TH.Desugar.AST.html#DCaseE"><span class="hs-identifier hs-var">DCaseE</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DExp
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarE"><span class="hs-identifier hs-var">DVarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415569"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DMatch
</span><a href="#local-6989586621679415564"><span class="hs-identifier hs-var">match</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-185"></span><span>      </span><span class="annot"><span class="annottext">DLetDec -&gt; m DLetDec
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(DLetDec -&gt; m DLetDec) -&gt; DLetDec -&gt; m DLetDec
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DExp -&gt; DLetDec
</span><a href="Language.Haskell.TH.Desugar.AST.html#DValD"><span class="hs-identifier hs-var">DValD</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415568"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DExp
</span><a href="#local-6989586621679415561"><span class="hs-identifier hs-var">cas</span></a></span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span>    </span><span id="local-6989586621679415565"><span class="annot"><span class="annottext">wildify :: Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var hs-var">wildify</span></a></span></span><span> </span><span id="local-6989586621679415559"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679415558"><span class="annot"><span class="annottext">y :: Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621679415557"><span class="annot"><span class="annottext">p :: DPat
</span><a href="#local-6989586621679415557"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-188"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415557"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-189"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLitP"><span class="hs-identifier hs-type">DLitP</span></a></span><span> </span><span id="local-6989586621679415555"><span class="annot"><span class="annottext">lit :: Lit
</span><a href="#local-6989586621679415555"><span class="hs-identifier hs-var">lit</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Lit -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DLitP"><span class="hs-identifier hs-var">DLitP</span></a></span><span> </span><span class="annot"><span class="annottext">Lit
</span><a href="#local-6989586621679415555"><span class="hs-identifier hs-var">lit</span></a></span><span>
</span><span id="line-190"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-type">DVarP</span></a></span><span> </span><span id="local-6989586621679415554"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679415554"><span class="hs-identifier hs-var">n</span></a></span></span><span>
</span><span id="line-191"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415554"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-192"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span><span>
</span><span id="line-193"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DConP"><span class="hs-identifier hs-type">DConP</span></a></span><span> </span><span id="local-6989586621679415551"><span class="annot"><span class="annottext">con :: Name
</span><a href="#local-6989586621679415551"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679415550"><span class="annot"><span class="annottext">ps :: [DPat]
</span><a href="#local-6989586621679415550"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [DPat] -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DConP"><span class="hs-identifier hs-var">DConP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415551"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(DPat -&gt; DPat) -&gt; [DPat] -&gt; [DPat]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var">wildify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DPat]
</span><a href="#local-6989586621679415550"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTildeP"><span class="hs-identifier hs-type">DTildeP</span></a></span><span> </span><span id="local-6989586621679415548"><span class="annot"><span class="annottext">pa :: DPat
</span><a href="#local-6989586621679415548"><span class="hs-identifier hs-var">pa</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DTildeP"><span class="hs-identifier hs-var">DTildeP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var">wildify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415548"><span class="hs-identifier hs-var">pa</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DBangP"><span class="hs-identifier hs-type">DBangP</span></a></span><span> </span><span id="local-6989586621679415546"><span class="annot"><span class="annottext">pa :: DPat
</span><a href="#local-6989586621679415546"><span class="hs-identifier hs-var">pa</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DBangP"><span class="hs-identifier hs-var">DBangP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var">wildify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415546"><span class="hs-identifier hs-var">pa</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigP"><span class="hs-identifier hs-type">DSigP</span></a></span><span> </span><span id="local-6989586621679415544"><span class="annot"><span class="annottext">pa :: DPat
</span><a href="#local-6989586621679415544"><span class="hs-identifier hs-var">pa</span></a></span></span><span> </span><span id="local-6989586621679415543"><span class="annot"><span class="annottext">ty :: DType
</span><a href="#local-6989586621679415543"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DPat -&gt; DType -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DSigP"><span class="hs-identifier hs-var">DSigP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; DPat -&gt; DPat
</span><a href="#local-6989586621679415565"><span class="hs-identifier hs-var">wildify</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415559"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415558"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="#local-6989586621679415544"><span class="hs-identifier hs-var">pa</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415543"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-197"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-type">DWildP</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.html#flattenDValD"><span class="hs-identifier hs-var">flattenDValD</span></a></span><span> </span><span id="local-6989586621679415542"><span class="annot"><span class="annottext">other_dec :: DLetDec
</span><a href="#local-6989586621679415542"><span class="hs-identifier hs-var">other_dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DLetDec] -&gt; q [DLetDec]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415542"><span class="hs-identifier hs-var">other_dec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | Produces 'DLetDec's representing the record selector functions from</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- the provided 'DCon's.</span><span>
</span><span id="line-203"></span><span class="hs-comment">--</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- Note that if the same record selector appears in multiple constructors,</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- 'getRecordSelectors' will return only one binding for that selector.</span><span>
</span><span id="line-206"></span><span class="hs-comment">-- For example, if you had:</span><span>
</span><span id="line-207"></span><span class="hs-comment">--</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- data X = X1 {y :: Symbol} | X2 {y :: Symbol}</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-211"></span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- Then calling 'getRecordSelectors' on @[X1, X2]@ will return:</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- [ DSigD y (DAppT (DAppT DArrowT (DConT X)) (DConT Symbol))</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- , DFunD y [ DClause [DConP X1 [DVarP field]] (DVarE field)</span><span>
</span><span id="line-217"></span><span class="hs-comment">--           , DClause [DConP X2 [DVarP field]] (DVarE field) ] ]</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-219"></span><span class="hs-comment">--</span><span>
</span><span id="line-220"></span><span class="hs-comment">-- instead of returning one binding for @X1@ and another binding for @X2@.</span><span>
</span><span id="line-221"></span><span class="hs-comment">--</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- 'getRecordSelectors' attempts to filter out \&quot;naughty\&quot; record selectors</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- whose types mention existentially quantified type variables. But see the</span><span>
</span><span id="line-224"></span><span class="hs-comment">-- documentation for 'conExistentialTvbs' for limitations to this approach.</span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span class="hs-comment">-- See https://github.com/goldfirere/singletons/issues/180 for an example where</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- the latter behavior can bite you.</span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span id="local-6989586621679415541"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#getRecordSelectors"><span class="hs-identifier hs-type">getRecordSelectors</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsMonad"><span class="hs-identifier hs-type">DsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679415541"><span class="hs-identifier hs-type">q</span></a></span><span>
</span><span id="line-230"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span>        </span><span class="hs-comment">-- ^ the type of the argument</span><span>
</span><span id="line-231"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-232"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415541"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-233"></span><span id="getRecordSelectors"><span class="annot"><span class="annottext">getRecordSelectors :: DType -&gt; [DCon] -&gt; q [DLetDec]
</span><a href="Language.Haskell.TH.Desugar.html#getRecordSelectors"><span class="hs-identifier hs-var hs-var">getRecordSelectors</span></a></span></span><span> </span><span id="local-6989586621679415540"><span class="annot"><span class="annottext">arg_ty :: DType
</span><a href="#local-6989586621679415540"><span class="hs-identifier hs-var">arg_ty</span></a></span></span><span> </span><span id="local-6989586621679415539"><span class="annot"><span class="annottext">cons :: [DCon]
</span><a href="#local-6989586621679415539"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415538"><span class="hs-identifier hs-var">merge_let_decs</span></a></span><span> </span><span class="annot"><span class="annottext">([DLetDec] -&gt; [DLetDec]) -&gt; q [DLetDec] -&gt; q [DLetDec]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">(DCon -&gt; q [DLetDec]) -&gt; [DCon] -&gt; q [DLetDec]
forall (monad :: * -&gt; *) monoid (t :: * -&gt; *) a.
(Monad monad, Monoid monoid, Traversable t) =&gt;
(a -&gt; monad monoid) -&gt; t a -&gt; monad monoid
</span><a href="Language.Haskell.TH.Desugar.Util.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span> </span><span class="annot"><span class="annottext">DCon -&gt; q [DLetDec]
forall (m :: * -&gt; *). DsMonad m =&gt; DCon -&gt; m [DLetDec]
</span><a href="#local-6989586621679415536"><span class="hs-identifier hs-var">get_record_sels</span></a></span><span> </span><span class="annot"><span class="annottext">[DCon]
</span><a href="#local-6989586621679415539"><span class="hs-identifier hs-var">cons</span></a></span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-235"></span><span>    </span><span id="local-6989586621679415536"><span class="annot"><span class="annottext">get_record_sels :: DCon -&gt; m [DLetDec]
</span><a href="#local-6989586621679415536"><span class="hs-identifier hs-var hs-var">get_record_sels</span></a></span></span><span> </span><span id="local-6989586621679415535"><span class="annot"><span class="annottext">con :: DCon
</span><a href="#local-6989586621679415535"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span> </span><span id="local-6989586621679415533"><span class="annot"><span class="annottext">con_tvbs :: [DTyVarBndr]
</span><a href="#local-6989586621679415533"><span class="hs-identifier hs-var">con_tvbs</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679415532"><span class="annot"><span class="annottext">con_name :: Name
</span><a href="#local-6989586621679415532"><span class="hs-identifier hs-var">con_name</span></a></span></span><span> </span><span id="local-6989586621679415531"><span class="annot"><span class="annottext">con_fields :: DConFields
</span><a href="#local-6989586621679415531"><span class="hs-identifier hs-var">con_fields</span></a></span></span><span> </span><span id="local-6989586621679415530"><span class="annot"><span class="annottext">con_ret_ty :: DType
</span><a href="#local-6989586621679415530"><span class="hs-identifier hs-var">con_ret_ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-236"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DConFields
</span><a href="#local-6989586621679415531"><span class="hs-identifier hs-var">con_fields</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-237"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DRecC"><span class="hs-identifier hs-type">DRecC</span></a></span><span> </span><span id="local-6989586621679415528"><span class="annot"><span class="annottext">fields :: [DVarBangType]
</span><a href="#local-6989586621679415528"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[DVarBangType] -&gt; m [DLetDec]
forall (m :: * -&gt; *) b.
DsMonad m =&gt;
[(Name, b, DType)] -&gt; m [DLetDec]
</span><a href="#local-6989586621679415527"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[DVarBangType]
</span><a href="#local-6989586621679415528"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-238"></span><span>        </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DNormalC"><span class="hs-identifier hs-type">DNormalC</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[DLetDec] -&gt; m [DLetDec]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-239"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-240"></span><span>          </span><span id="local-6989586621679415527"><span class="annot"><span class="annottext">go :: [(Name, b, DType)] -&gt; m [DLetDec]
</span><a href="#local-6989586621679415527"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679415525"><span class="annot"><span class="annottext">fields :: [(Name, b, DType)]
</span><a href="#local-6989586621679415525"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-241"></span><span>            </span><span id="local-6989586621679415524"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415524"><span class="hs-identifier hs-var">varName</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; m Name
forall (q :: * -&gt; *). Quasi q =&gt; String -&gt; q Name
</span><span class="hs-identifier hs-var">qNewName</span></span><span> </span><span class="annot"><span class="hs-string">&quot;field&quot;</span></span><span>
</span><span id="line-242"></span><span>            </span><span id="local-6989586621679415522"><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415522"><span class="hs-identifier hs-var">con_ex_tvbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DType -&gt; DCon -&gt; m [DTyVarBndr]
forall (q :: * -&gt; *). DsMonad q =&gt; DType -&gt; DCon -&gt; q [DTyVarBndr]
</span><a href="Language.Haskell.TH.Desugar.html#conExistentialTvbs"><span class="hs-identifier hs-var">conExistentialTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415540"><span class="hs-identifier hs-var">arg_ty</span></a></span><span> </span><span class="annot"><span class="annottext">DCon
</span><a href="#local-6989586621679415535"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-243"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679415521"><span class="annot"><span class="annottext">con_univ_tvbs :: [DTyVarBndr]
</span><a href="#local-6989586621679415521"><span class="hs-identifier hs-var hs-var">con_univ_tvbs</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(DTyVarBndr -&gt; DTyVarBndr -&gt; Bool)
-&gt; [DTyVarBndr] -&gt; [DTyVarBndr] -&gt; [DTyVarBndr]
forall a. (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">deleteFirstsBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">(==)</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Name -&gt; Bool)
-&gt; (DTyVarBndr -&gt; Name) -&gt; DTyVarBndr -&gt; DTyVarBndr -&gt; Bool
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="annot"><span class="annottext">DTyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Desugar.Core.html#dtvbName"><span class="hs-identifier hs-var">dtvbName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415533"><span class="hs-identifier hs-var">con_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415522"><span class="hs-identifier hs-var">con_ex_tvbs</span></a></span><span>
</span><span id="line-244"></span><span>                </span><span id="local-6989586621679415517"><span class="annot"><span class="annottext">con_ex_tvb_set :: OSet Name
</span><a href="#local-6989586621679415517"><span class="hs-identifier hs-var hs-var">con_ex_tvb_set</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; OSet Name
forall a. Ord a =&gt; [a] -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#fromList"><span class="hs-identifier hs-var">OS.fromList</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; OSet Name) -&gt; [Name] -&gt; OSet Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(DTyVarBndr -&gt; Name) -&gt; [DTyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">DTyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Desugar.Core.html#dtvbName"><span class="hs-identifier hs-var">dtvbName</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415522"><span class="hs-identifier hs-var">con_ex_tvbs</span></a></span><span>
</span><span id="line-245"></span><span>                </span><span id="local-6989586621679415515"><span class="annot"><span class="annottext">forall' :: DType -&gt; DType
</span><a href="#local-6989586621679415515"><span class="hs-identifier hs-var hs-var">forall'</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr] -&gt; DCxt -&gt; DType -&gt; DType
</span><a href="Language.Haskell.TH.Desugar.AST.html#DForallT"><span class="hs-identifier hs-var">DForallT</span></a></span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415521"><span class="hs-identifier hs-var">con_univ_tvbs</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-246"></span><span>                </span><span id="local-6989586621679415513"><span class="annot"><span class="annottext">num_pats :: Int
</span><a href="#local-6989586621679415513"><span class="hs-identifier hs-var hs-var">num_pats</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, b, DType)] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[(Name, b, DType)]
</span><a href="#local-6989586621679415525"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-247"></span><span>            </span><span class="annot"><span class="annottext">[DLetDec] -&gt; m [DLetDec]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([DLetDec] -&gt; m [DLetDec]) -&gt; [DLetDec] -&gt; m [DLetDec]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[[DLetDec]] -&gt; [DLetDec]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span>
</span><span id="line-248"></span><span>              </span><span class="hs-special">[</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Name -&gt; DType -&gt; DLetDec
</span><a href="Language.Haskell.TH.Desugar.AST.html#DSigD"><span class="hs-identifier hs-var">DSigD</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415509"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DType -&gt; DType
</span><a href="#local-6989586621679415515"><span class="hs-identifier hs-var">forall'</span></a></span><span> </span><span class="annot"><span class="annottext">(DType -&gt; DType) -&gt; DType -&gt; DType
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="Language.Haskell.TH.Desugar.AST.html#DArrowT"><span class="hs-identifier hs-var">DArrowT</span></a></span><span> </span><span class="annot"><span class="annottext">DType -&gt; DType -&gt; DType
</span><a href="Language.Haskell.TH.Desugar.AST.html#DAppT"><span class="hs-operator hs-var">`DAppT`</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415530"><span class="hs-identifier hs-var">con_ret_ty</span></a></span><span> </span><span class="annot"><span class="annottext">DType -&gt; DType -&gt; DType
</span><a href="Language.Haskell.TH.Desugar.AST.html#DAppT"><span class="hs-operator hs-var">`DAppT`</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415506"><span class="hs-identifier hs-var">field_ty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-249"></span><span>                </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [DClause] -&gt; DLetDec
</span><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-var">DFunD</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415509"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[DPat] -&gt; DExp -&gt; DClause
</span><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-var">DClause</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name -&gt; [DPat] -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DConP"><span class="hs-identifier hs-var">DConP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415532"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Name -&gt; [DPat]
</span><a href="#local-6989586621679415503"><span class="hs-identifier hs-var">mk_field_pats</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679415502"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679415513"><span class="hs-identifier hs-var">num_pats</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415524"><span class="hs-identifier hs-var">varName</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-250"></span><span>                                      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; DExp
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarE"><span class="hs-identifier hs-var">DVarE</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415524"><span class="hs-identifier hs-var">varName</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-251"></span><span>              </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679415509"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679415509"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415501"><span class="annot"><span class="annottext">_strict :: b
</span><a href="#local-6989586621679415501"><span class="hs-identifier hs-var">_strict</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415506"><span class="annot"><span class="annottext">field_ty :: DType
</span><a href="#local-6989586621679415506"><span class="hs-identifier hs-var">field_ty</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415502"><span class="annot"><span class="annottext">n :: Int
</span><a href="#local-6989586621679415502"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Name, b, DType)] -&gt; [Int] -&gt; [((Name, b, DType), Int)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[(Name, b, DType)]
</span><a href="#local-6989586621679415525"><span class="hs-identifier hs-var">fields</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-number">0</span></span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-252"></span><span>              </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; Bool
forall a. OSet a -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.OSet.html#null"><span class="hs-identifier hs-var">OS.null</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DType -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.FV.html#fvDType"><span class="hs-identifier hs-var">fvDType</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415506"><span class="hs-identifier hs-var">field_ty</span></a></span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; OSet Name -&gt; OSet Name
forall a. Ord a =&gt; OSet a -&gt; OSet a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#intersection"><span class="hs-operator hs-var">`OS.intersection`</span></a></span><span> </span><span class="annot"><span class="annottext">OSet Name
</span><a href="#local-6989586621679415517"><span class="hs-identifier hs-var">con_ex_tvb_set</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-253"></span><span>                  </span><span class="hs-comment">-- exclude &quot;naughty&quot; selectors</span><span>
</span><span id="line-254"></span><span>              </span><span class="hs-special">]</span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span>    </span><span class="annot"><a href="#local-6989586621679415503"><span class="hs-identifier hs-type">mk_field_pats</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DPat"><span class="hs-identifier hs-type">DPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-257"></span><span>    </span><span id="local-6989586621679415503"><span class="annot"><span class="annottext">mk_field_pats :: Int -&gt; Int -&gt; Name -&gt; [DPat]
</span><a href="#local-6989586621679415503"><span class="hs-identifier hs-var hs-var">mk_field_pats</span></a></span></span><span> </span><span class="hs-number">0</span><span> </span><span id="local-6989586621679415497"><span class="annot"><span class="annottext">total :: Int
</span><a href="#local-6989586621679415497"><span class="hs-identifier hs-var">total</span></a></span></span><span> </span><span id="local-6989586621679415496"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679415496"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DVarP"><span class="hs-identifier hs-var">DVarP</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415496"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">DPat -&gt; [DPat] -&gt; [DPat]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; DPat -&gt; [DPat]
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679415497"><span class="hs-identifier hs-var">total</span></a></span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-258"></span><span>    </span><span class="annot"><a href="#local-6989586621679415503"><span class="hs-identifier hs-var">mk_field_pats</span></a></span><span> </span><span id="local-6989586621679415494"><span class="annot"><span class="annottext">n :: Int
</span><a href="#local-6989586621679415494"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679415493"><span class="annot"><span class="annottext">total :: Int
</span><a href="#local-6989586621679415493"><span class="hs-identifier hs-var">total</span></a></span></span><span> </span><span id="local-6989586621679415492"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679415492"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DPat
</span><a href="Language.Haskell.TH.Desugar.AST.html#DWildP"><span class="hs-identifier hs-var">DWildP</span></a></span><span> </span><span class="annot"><span class="annottext">DPat -&gt; [DPat] -&gt; [DPat]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Name -&gt; [DPat]
</span><a href="#local-6989586621679415503"><span class="hs-identifier hs-var">mk_field_pats</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679415494"><span class="hs-identifier hs-var">n</span></a></span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679415493"><span class="hs-identifier hs-var">total</span></a></span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415492"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-259"></span><span>
</span><span id="line-260"></span><span>    </span><span class="annot"><a href="#local-6989586621679415538"><span class="hs-identifier hs-type">merge_let_decs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-261"></span><span>    </span><span id="local-6989586621679415538"><span class="annot"><span class="annottext">merge_let_decs :: [DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415538"><span class="hs-identifier hs-var hs-var">merge_let_decs</span></a></span></span><span> </span><span id="local-6989586621679415491"><span class="annot"><span class="annottext">decs :: [DLetDec]
</span><a href="#local-6989586621679415491"><span class="hs-identifier hs-var">decs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-262"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415490"><span class="annot"><span class="annottext">name_clause_map :: Map Name [DClause]
</span><a href="#local-6989586621679415490"><span class="hs-identifier hs-var">name_clause_map</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415489"><span class="annot"><span class="annottext">decs' :: [DLetDec]
</span><a href="#local-6989586621679415489"><span class="hs-identifier hs-var">decs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
forall k a. Map k a
</span><span class="hs-identifier hs-var">M.empty</span></span><span> </span><span class="annot"><span class="annottext">Set Name
forall a. Set a
</span><span class="hs-identifier hs-var">S.empty</span></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415491"><span class="hs-identifier hs-var">decs</span></a></span><span>
</span><span id="line-263"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause] -&gt; [DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415485"><span class="hs-identifier hs-var">augment_clauses</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415490"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415489"><span class="hs-identifier hs-var">decs'</span></a></span><span>
</span><span id="line-264"></span><span>        </span><span class="hs-comment">-- First, for each record selector-related declarations, do the following:</span><span>
</span><span id="line-265"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-266"></span><span>        </span><span class="hs-comment">-- 1. If it's a DFunD...</span><span>
</span><span id="line-267"></span><span>        </span><span class="hs-comment">--   a. If we haven't encountered it before, add a mapping from its Name</span><span>
</span><span id="line-268"></span><span>        </span><span class="hs-comment">--      to its associated DClauses, and continue.</span><span>
</span><span id="line-269"></span><span>        </span><span class="hs-comment">--   b. If we have encountered it before, augment the existing Name's</span><span>
</span><span id="line-270"></span><span>        </span><span class="hs-comment">--      mapping with the new clauses. Then remove the DFunD from the list</span><span>
</span><span id="line-271"></span><span>        </span><span class="hs-comment">--      and continue.</span><span>
</span><span id="line-272"></span><span>        </span><span class="hs-comment">-- 2. If it's a DSigD...</span><span>
</span><span id="line-273"></span><span>        </span><span class="hs-comment">--   a. If we haven't encountered it before, remember its Name and continue.</span><span>
</span><span id="line-274"></span><span>        </span><span class="hs-comment">--   b. If we have encountered it before, remove the DSigD from the list</span><span>
</span><span id="line-275"></span><span>        </span><span class="hs-comment">--      and continue.</span><span>
</span><span id="line-276"></span><span>        </span><span class="hs-comment">-- 3. Otherwise, continue.</span><span>
</span><span id="line-277"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-278"></span><span>        </span><span class="hs-comment">-- After this, scan over the resulting list once more with the mapping</span><span>
</span><span id="line-279"></span><span>        </span><span class="hs-comment">-- that we accumulated. For every DFunD, replace its DClauses with the</span><span>
</span><span id="line-280"></span><span>        </span><span class="hs-comment">-- ones corresponding to its Name in the mapping.</span><span>
</span><span id="line-281"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-282"></span><span>        </span><span class="hs-comment">-- Note that this algorithm combines all of the DClauses for each unique</span><span>
</span><span id="line-283"></span><span>        </span><span class="hs-comment">-- Name, while preserving the order in which the DFunDs were originally</span><span>
</span><span id="line-284"></span><span>        </span><span class="hs-comment">-- found. Moreover, it removes duplicate DSigD entries. Using Maps and</span><span>
</span><span id="line-285"></span><span>        </span><span class="hs-comment">-- Sets avoid quadratic blowup for data types with many record selectors.</span><span>
</span><span id="line-286"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-287"></span><span>        </span><span class="annot"><a href="#local-6989586621679415488"><span class="hs-identifier hs-type">gather_decs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">S.Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-288"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span>        </span><span id="local-6989586621679415488"><span class="annot"><span class="annottext">gather_decs :: Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var hs-var">gather_decs</span></a></span></span><span> </span><span id="local-6989586621679415484"><span class="annot"><span class="annottext">name_clause_map :: Map Name [DClause]
</span><a href="#local-6989586621679415484"><span class="hs-identifier hs-var">name_clause_map</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415484"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-290"></span><span>        </span><span class="annot"><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span id="local-6989586621679415483"><span class="annot"><span class="annottext">name_clause_map :: Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span></span><span> </span><span id="local-6989586621679415482"><span class="annot"><span class="annottext">type_sig_names :: Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415481"><span class="annot"><span class="annottext">x :: DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679415480"><span class="annot"><span class="annottext">xs :: [DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>          </span><span class="hs-comment">-- 1.</span><span>
</span><span id="line-292"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-type">DFunD</span></a></span><span> </span><span id="local-6989586621679415479"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679415479"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679415478"><span class="annot"><span class="annottext">clauses :: [DClause]
</span><a href="#local-6989586621679415478"><span class="hs-identifier hs-var">clauses</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-293"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679415477"><span class="annot"><span class="annottext">name_clause_map' :: Map Name [DClause]
</span><a href="#local-6989586621679415477"><span class="hs-identifier hs-var hs-var">name_clause_map'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([DClause] -&gt; [DClause] -&gt; [DClause])
-&gt; Name -&gt; [DClause] -&gt; Map Name [DClause] -&gt; Map Name [DClause]
forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">M.insertWith</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679415475"><span class="annot"><span class="annottext">new :: [DClause]
</span><a href="#local-6989586621679415475"><span class="hs-identifier hs-var">new</span></a></span></span><span> </span><span id="local-6989586621679415474"><span class="annot"><span class="annottext">old :: [DClause]
</span><a href="#local-6989586621679415474"><span class="hs-identifier hs-var">old</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621679415474"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">[DClause] -&gt; [DClause] -&gt; [DClause]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621679415475"><span class="hs-identifier hs-var">new</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-294"></span><span>                                                </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415479"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621679415478"><span class="hs-identifier hs-var">clauses</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span>
</span><span id="line-295"></span><span>             </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415479"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name [DClause] -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-operator hs-var">`M.member`</span></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span>
</span><span id="line-296"></span><span>                </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415477"><span class="hs-identifier hs-var">name_clause_map'</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-297"></span><span>                </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415472"><span class="annot"><span class="annottext">map' :: Map Name [DClause]
</span><a href="#local-6989586621679415472"><span class="hs-identifier hs-var">map'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415471"><span class="annot"><span class="annottext">decs' :: [DLetDec]
</span><a href="#local-6989586621679415471"><span class="hs-identifier hs-var">decs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415477"><span class="hs-identifier hs-var">name_clause_map'</span></a></span><span>
</span><span id="line-298"></span><span>                                           </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-299"></span><span>                      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415472"><span class="hs-identifier hs-var">map'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415471"><span class="hs-identifier hs-var">decs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>
</span><span id="line-301"></span><span>          </span><span class="hs-comment">-- 2.</span><span>
</span><span id="line-302"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DSigD"><span class="hs-identifier hs-type">DSigD</span></a></span><span> </span><span id="local-6989586621679415470"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679415470"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-303"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415470"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Bool
forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span>
</span><span id="line-304"></span><span>            </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-305"></span><span>            </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415468"><span class="annot"><span class="annottext">map' :: Map Name [DClause]
</span><a href="#local-6989586621679415468"><span class="hs-identifier hs-var">map'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415467"><span class="annot"><span class="annottext">decs' :: [DLetDec]
</span><a href="#local-6989586621679415467"><span class="hs-identifier hs-var">decs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span>
</span><span id="line-306"></span><span>                                       </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415470"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Set Name
forall a. Ord a =&gt; a -&gt; Set a -&gt; Set a
</span><span class="hs-operator hs-var">`S.insert`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-307"></span><span>                  </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415468"><span class="hs-identifier hs-var">map'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415467"><span class="hs-identifier hs-var">decs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span>          </span><span class="hs-comment">-- 3.</span><span>
</span><span id="line-310"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-311"></span><span>              </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415465"><span class="annot"><span class="annottext">map' :: Map Name [DClause]
</span><a href="#local-6989586621679415465"><span class="hs-identifier hs-var">map'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679415464"><span class="annot"><span class="annottext">decs' :: [DLetDec]
</span><a href="#local-6989586621679415464"><span class="hs-identifier hs-var">decs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
-&gt; Set Name -&gt; [DLetDec] -&gt; (Map Name [DClause], [DLetDec])
</span><a href="#local-6989586621679415488"><span class="hs-identifier hs-var">gather_decs</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415483"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679415482"><span class="hs-identifier hs-var">type_sig_names</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415480"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-312"></span><span>               </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415465"><span class="hs-identifier hs-var">map'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415481"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415464"><span class="hs-identifier hs-var">decs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span>        </span><span class="annot"><a href="#local-6989586621679415485"><span class="hs-identifier hs-type">augment_clauses</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">M.Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DClause"><span class="hs-identifier hs-type">DClause</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DLetDec"><span class="hs-identifier hs-type">DLetDec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-315"></span><span>        </span><span id="local-6989586621679415485"><span class="annot"><span class="annottext">augment_clauses :: Map Name [DClause] -&gt; [DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415485"><span class="hs-identifier hs-var hs-var">augment_clauses</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-316"></span><span>        </span><span class="annot"><a href="#local-6989586621679415485"><span class="hs-identifier hs-var">augment_clauses</span></a></span><span> </span><span id="local-6989586621679415463"><span class="annot"><span class="annottext">name_clause_map :: Map Name [DClause]
</span><a href="#local-6989586621679415463"><span class="hs-identifier hs-var">name_clause_map</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679415462"><span class="annot"><span class="annottext">x :: DLetDec
</span><a href="#local-6989586621679415462"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679415461"><span class="annot"><span class="annottext">xs :: [DLetDec]
</span><a href="#local-6989586621679415461"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-type">DFunD</span></a></span><span> </span><span id="local-6989586621679415460"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679415460"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415462"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679415459"><span class="annot"><span class="annottext">merged_clauses :: [DClause]
</span><a href="#local-6989586621679415459"><span class="hs-identifier hs-var">merged_clauses</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415460"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name [DClause] -&gt; Maybe [DClause]
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-operator hs-var">`M.lookup`</span></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415463"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span>
</span><span id="line-318"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [DClause] -&gt; DLetDec
</span><a href="Language.Haskell.TH.Desugar.AST.html#DFunD"><span class="hs-identifier hs-var">DFunD</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679415460"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[DClause]
</span><a href="#local-6989586621679415459"><span class="hs-identifier hs-var">merged_clauses</span></a></span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Map Name [DClause] -&gt; [DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415485"><span class="hs-identifier hs-var">augment_clauses</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415463"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415461"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-319"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DLetDec
</span><a href="#local-6989586621679415462"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">DLetDec -&gt; [DLetDec] -&gt; [DLetDec]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Map Name [DClause] -&gt; [DLetDec] -&gt; [DLetDec]
</span><a href="#local-6989586621679415485"><span class="hs-identifier hs-var">augment_clauses</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name [DClause]
</span><a href="#local-6989586621679415463"><span class="hs-identifier hs-var">name_clause_map</span></a></span><span> </span><span class="annot"><span class="annottext">[DLetDec]
</span><a href="#local-6989586621679415461"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-320"></span><span>
</span><span id="line-321"></span><span class="hs-comment">-- | Create new kind variable binder names corresponding to the return kind of</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- a data type. This is useful when you have a data type like:</span><span>
</span><span id="line-323"></span><span class="hs-comment">--</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-325"></span><span class="hs-comment">-- data Foo :: forall k. k -&gt; Type -&gt; Type where ...</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-327"></span><span class="hs-comment">--</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- But you want to be able to refer to the type @Foo a b@.</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- 'mkExtraDKindBinders' will take the kind @forall k. k -&gt; Type -&gt; Type@,</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- discover that is has two visible argument kinds, and return as a result</span><span>
</span><span id="line-331"></span><span class="hs-comment">-- two new kind variable binders @[a :: k, b :: Type]@, where @a@ and @b@</span><span>
</span><span id="line-332"></span><span class="hs-comment">-- are fresh type variable names.</span><span>
</span><span id="line-333"></span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- This expands kind synonyms if necessary.</span><span>
</span><span id="line-335"></span><span id="local-6989586621679415457"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#mkExtraDKindBinders"><span class="hs-identifier hs-type">mkExtraDKindBinders</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsMonad"><span class="hs-identifier hs-type">DsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679415457"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DKind"><span class="hs-identifier hs-type">DKind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415457"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-336"></span><span id="mkExtraDKindBinders"><span class="annot"><span class="annottext">mkExtraDKindBinders :: DType -&gt; q [DTyVarBndr]
</span><a href="Language.Haskell.TH.Desugar.html#mkExtraDKindBinders"><span class="hs-identifier hs-var hs-var">mkExtraDKindBinders</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DType -&gt; q DType
forall (q :: * -&gt; *). DsMonad q =&gt; DType -&gt; q DType
</span><a href="Language.Haskell.TH.Desugar.Expand.html#expandType"><span class="hs-identifier hs-var">expandType</span></a></span><span> </span><span class="annot"><span class="annottext">(DType -&gt; q DType)
-&gt; (DType -&gt; q [DTyVarBndr]) -&gt; DType -&gt; q [DTyVarBndr]
forall (m :: * -&gt; *) a b c.
Monad m =&gt;
(a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
</span><span class="hs-operator hs-var">&gt;=&gt;</span></span><span> </span><span class="annot"><span class="annottext">DType -&gt; q [DTyVarBndr]
forall (q :: * -&gt; *). Quasi q =&gt; DType -&gt; q [DTyVarBndr]
</span><a href="Language.Haskell.TH.Desugar.Core.html#mkExtraDKindBinders%27"><span class="hs-identifier hs-var">mkExtraDKindBinders'</span></a></span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span class="hs-comment">-- | Returns all of a constructor's existentially quantified type variable</span><span>
</span><span id="line-339"></span><span class="hs-comment">-- binders.</span><span>
</span><span id="line-340"></span><span class="hs-comment">--</span><span>
</span><span id="line-341"></span><span class="hs-comment">-- Detecting the presence of existentially quantified type variables in the</span><span>
</span><span id="line-342"></span><span class="hs-comment">-- context of Template Haskell is quite involved. Here is an example that</span><span>
</span><span id="line-343"></span><span class="hs-comment">-- we will use to explain how this works:</span><span>
</span><span id="line-344"></span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-346"></span><span class="hs-comment">-- data family Foo a b</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- data instance Foo (Maybe a) b where</span><span>
</span><span id="line-348"></span><span class="hs-comment">--   MkFoo :: forall x y z. x -&gt; y -&gt; z -&gt; Foo (Maybe x) [z]</span><span>
</span><span id="line-349"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-350"></span><span class="hs-comment">--</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- In @MkFoo@, @x@ is universally quantified, whereas @y@ and @z@ are</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- existentially quantified. Note that @MkFoo@ desugars (in Core) to</span><span>
</span><span id="line-353"></span><span class="hs-comment">-- something like this:</span><span>
</span><span id="line-354"></span><span class="hs-comment">--</span><span>
</span><span id="line-355"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- data instance Foo (Maybe a) b where</span><span>
</span><span id="line-357"></span><span class="hs-comment">--   MkFoo :: forall a b y z. (b ~ [z]). a -&gt; y -&gt; z -&gt; Foo (Maybe a) b</span><span>
</span><span id="line-358"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-359"></span><span class="hs-comment">--</span><span>
</span><span id="line-360"></span><span class="hs-comment">-- Here, we can see that @a@ appears in the desugared return type (it is a</span><span>
</span><span id="line-361"></span><span class="hs-comment">-- simple alpha-renaming of @x@), so it is universally quantified. On the other</span><span>
</span><span id="line-362"></span><span class="hs-comment">-- hand, neither @y@ nor @z@ appear in the desugared return type, so they are</span><span>
</span><span id="line-363"></span><span class="hs-comment">-- existentially quantified.</span><span>
</span><span id="line-364"></span><span class="hs-comment">--</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- This analysis would not have been possible without knowing what the original</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- data declaration's type was (in this case, @Foo (Maybe a) b@), which is why</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- we require it as an argument. Our algorithm for detecting existentially</span><span>
</span><span id="line-368"></span><span class="hs-comment">-- quantified variables is not too different from what was described above:</span><span>
</span><span id="line-369"></span><span class="hs-comment">-- we match the constructor's return type with the original data type, forming</span><span>
</span><span id="line-370"></span><span class="hs-comment">-- a substitution, and check which quantified variables are not part of the</span><span>
</span><span id="line-371"></span><span class="hs-comment">-- domain of the substitution.</span><span>
</span><span id="line-372"></span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span class="hs-comment">-- Be warned: this may overestimate which variables are existentially</span><span>
</span><span id="line-374"></span><span class="hs-comment">-- quantified when kind variables are involved. For instance, consider this</span><span>
</span><span id="line-375"></span><span class="hs-comment">-- example:</span><span>
</span><span id="line-376"></span><span class="hs-comment">--</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- data S k (a :: k)</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- data T a where</span><span>
</span><span id="line-380"></span><span class="hs-comment">--   MkT :: forall k (a :: k). { foo :: Proxy (a :: k), bar :: S k a } -&gt; T a</span><span>
</span><span id="line-381"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-382"></span><span class="hs-comment">--</span><span>
</span><span id="line-383"></span><span class="hs-comment">-- Here, the kind variable @k@ does not appear syntactically in the return type</span><span>
</span><span id="line-384"></span><span class="hs-comment">-- @T a@, so 'conExistentialTvbs' would mistakenly flag @k@ as existential.</span><span>
</span><span id="line-385"></span><span class="hs-comment">--</span><span>
</span><span id="line-386"></span><span class="hs-comment">-- There are various tricks we could employ to improve this, but ultimately,</span><span>
</span><span id="line-387"></span><span class="hs-comment">-- making this behave correctly with respect to @PolyKinds@ 100% of the time</span><span>
</span><span id="line-388"></span><span class="hs-comment">-- would amount to performing kind inference in Template Haskell, which is</span><span>
</span><span id="line-389"></span><span class="hs-comment">-- quite difficult. For the sake of simplicity, we have decided to stick with</span><span>
</span><span id="line-390"></span><span class="hs-comment">-- a dumb-but-predictable syntactic check.</span><span>
</span><span id="line-391"></span><span id="local-6989586621679415780"><span class="annot"><a href="Language.Haskell.TH.Desugar.html#conExistentialTvbs"><span class="hs-identifier hs-type">conExistentialTvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Reify.html#DsMonad"><span class="hs-identifier hs-type">DsMonad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679415780"><span class="hs-identifier hs-type">q</span></a></span><span>
</span><span id="line-392"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DType"><span class="hs-identifier hs-type">DType</span></a></span><span> </span><span class="hs-comment">-- ^ The type of the original data declaration</span><span>
</span><span id="line-393"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span>
</span><span id="line-394"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679415780"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DTyVarBndr"><span class="hs-identifier hs-type">DTyVarBndr</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-395"></span><span id="conExistentialTvbs"><span class="annot"><span class="annottext">conExistentialTvbs :: DType -&gt; DCon -&gt; q [DTyVarBndr]
</span><a href="Language.Haskell.TH.Desugar.html#conExistentialTvbs"><span class="hs-identifier hs-var hs-var">conExistentialTvbs</span></a></span></span><span> </span><span id="local-6989586621679415454"><span class="annot"><span class="annottext">data_ty :: DType
</span><a href="#local-6989586621679415454"><span class="hs-identifier hs-var">data_ty</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.AST.html#DCon"><span class="hs-identifier hs-type">DCon</span></a></span><span> </span><span id="local-6989586621679415453"><span class="annot"><span class="annottext">tvbs :: [DTyVarBndr]
</span><a href="#local-6989586621679415453"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679415452"><span class="annot"><span class="annottext">ret_ty :: DType
</span><a href="#local-6989586621679415452"><span class="hs-identifier hs-var">ret_ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-396"></span><span>  </span><span id="local-6989586621679415451"><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415451"><span class="hs-identifier hs-var">data_ty'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DType -&gt; q DType
forall (q :: * -&gt; *). DsMonad q =&gt; DType -&gt; q DType
</span><a href="Language.Haskell.TH.Desugar.Expand.html#expandType"><span class="hs-identifier hs-var">expandType</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415454"><span class="hs-identifier hs-var">data_ty</span></a></span><span>
</span><span id="line-397"></span><span>  </span><span id="local-6989586621679415450"><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415450"><span class="hs-identifier hs-var">ret_ty'</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DType -&gt; q DType
forall (q :: * -&gt; *). DsMonad q =&gt; DType -&gt; q DType
</span><a href="Language.Haskell.TH.Desugar.Expand.html#expandType"><span class="hs-identifier hs-var">expandType</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415452"><span class="hs-identifier hs-var">ret_ty</span></a></span><span>
</span><span id="line-398"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">IgnoreKinds -&gt; DType -&gt; DType -&gt; Maybe DSubst
</span><a href="Language.Haskell.TH.Desugar.Subst.html#matchTy"><span class="hs-identifier hs-var">matchTy</span></a></span><span> </span><span class="annot"><span class="annottext">IgnoreKinds
</span><a href="Language.Haskell.TH.Desugar.Subst.html#YesIgnore"><span class="hs-identifier hs-var">YesIgnore</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415450"><span class="hs-identifier hs-var">ret_ty'</span></a></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415451"><span class="hs-identifier hs-var">data_ty'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-399"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; q [DTyVarBndr]
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; q [DTyVarBndr]) -&gt; String -&gt; q [DTyVarBndr]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Unable to match type &quot;</span></span><span>
</span><span id="line-400"></span><span>                    </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; DType -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415450"><span class="hs-identifier hs-var">ret_ty'</span></a></span><span>
</span><span id="line-401"></span><span>                    </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="hs-string">&quot; with &quot;</span></span><span>
</span><span id="line-402"></span><span>                    </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; DType -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">DType
</span><a href="#local-6989586621679415451"><span class="hs-identifier hs-var">data_ty'</span></a></span><span>
</span><span id="line-403"></span><span>                    </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-404"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679415444"><span class="annot"><span class="annottext">gadtSubt :: DSubst
</span><a href="#local-6989586621679415444"><span class="hs-identifier hs-var">gadtSubt</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr] -&gt; q [DTyVarBndr]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">DTyVarBndr
</span><a href="#local-6989586621679415443"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-405"></span><span>                            </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679415443"><span class="annot"><span class="annottext">DTyVarBndr
</span><a href="#local-6989586621679415443"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[DTyVarBndr]
</span><a href="#local-6989586621679415453"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-406"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; DSubst -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.notMember</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DTyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Desugar.Core.html#dtvbName"><span class="hs-identifier hs-var">dtvbName</span></a></span><span> </span><span class="annot"><span class="annottext">DTyVarBndr
</span><a href="#local-6989586621679415443"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">DSubst
</span><a href="#local-6989586621679415444"><span class="hs-identifier hs-var">gadtSubt</span></a></span><span>
</span><span id="line-407"></span><span>                            </span><span class="hs-special">]</span><span>
</span><span id="line-408"></span></pre></body></html>