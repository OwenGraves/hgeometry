<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">{- Language/Haskell/TH/Desugar/Util.hs

(c) Richard Eisenberg 2013
rae@cs.brynmawr.edu

Utility functions for th-desugar package.
-}</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE CPP, DeriveDataTypeable, RankNTypes, ScopedTypeVariables, TupleSections #-}</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskellQuotes #-}</span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-17"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Desugar.Util</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-18"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier">newUniqueName</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#impossible"><span class="hs-identifier">impossible</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#nameOccursIn"><span class="hs-identifier">nameOccursIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#allNamesIn"><span class="hs-identifier">allNamesIn</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkTypeName"><span class="hs-identifier">mkTypeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkDataName"><span class="hs-identifier">mkDataName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkNameWith"><span class="hs-identifier">mkNameWith</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isDataName"><span class="hs-identifier">isDataName</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-21"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripVarP_maybe"><span class="hs-identifier">stripVarP_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier">extractBoundNamesStmt</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-22"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#concatMapM"><span class="hs-identifier">concatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapAccumLM"><span class="hs-identifier">mapAccumLM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapMaybeM"><span class="hs-identifier">mapMaybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#expectJustM"><span class="hs-identifier">expectJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripPlainTV_maybe"><span class="hs-identifier">stripPlainTV_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#thirdOf3"><span class="hs-identifier">thirdOf3</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier">splitAtList</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier">extractBoundNamesDec</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier">extractBoundNamesPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToType"><span class="hs-identifier">tvbToType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTypeWithSig"><span class="hs-identifier">tvbToTypeWithSig</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTANormalWithSig"><span class="hs-identifier">tvbToTANormalWithSig</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#nameMatches"><span class="hs-identifier">nameMatches</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#thdOf3"><span class="hs-identifier">thdOf3</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#firstMatch"><span class="hs-identifier">firstMatch</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumDegree_maybe"><span class="hs-identifier">unboxedSumDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumNameDegree_maybe"><span class="hs-identifier">unboxedSumNameDegree_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleDegree_maybe"><span class="hs-identifier">tupleDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleNameDegree_maybe"><span class="hs-identifier">tupleNameDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleDegree_maybe"><span class="hs-identifier">unboxedTupleDegree_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleNameDegree_maybe"><span class="hs-identifier">unboxedTupleNameDegree_maybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitTuple_maybe"><span class="hs-identifier">splitTuple_maybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#topEverywhereM"><span class="hs-identifier">topEverywhereM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isInfixDataCon"><span class="hs-identifier">isInfixDataCon</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isTypeKindName"><span class="hs-identifier">isTypeKindName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#typeKindName"><span class="hs-identifier">typeKindName</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkExtraKindBindersGeneric"><span class="hs-identifier">mkExtraKindBindersGeneric</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier">unravelType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier">unSigType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unfoldType"><span class="hs-identifier">unfoldType</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier">TypeArg</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#applyType"><span class="hs-identifier">applyType</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#filterTANormals"><span class="hs-identifier">filterTANormals</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigTypeArg"><span class="hs-identifier">unSigTypeArg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#probablyWrongUnTypeArg"><span class="hs-identifier">probablyWrongUnTypeArg</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#bindIP"><span class="hs-identifier">bindIP</span></a></span><span class="hs-cpp">
#endif
</span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">mapM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">foldl</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">concatMap</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">any</span></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">cxt</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Datatype</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">tvName</span></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.OSet</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">OS</span></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html"><span class="hs-identifier">Language.Haskell.TH.Desugar.OSet</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html#OSet"><span class="hs-identifier">OSet</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">replicateM</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Fail</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Fail</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Generics</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Fixity</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Traversable</span></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 710
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data.Monoid</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Kind</span></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Classes</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">IP</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unsafe.Coerce</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">unsafeCoerce</span></span><span> </span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-65"></span><span class="hs-comment">----------------------------------------</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- TH manipulations</span><span>
</span><span id="line-67"></span><span class="hs-comment">----------------------------------------</span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span class="hs-comment">-- | Like newName, but even more unique (unique across different splices),</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- and with unique @nameBase@s. Precondition: the string is a valid Haskell</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- alphanumeric identifier (could be upper- or lower-case).</span><span>
</span><span id="line-72"></span><span id="local-6989586621679411137"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier hs-type">newUniqueName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679411137"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411137"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span></span><span>
</span><span id="line-73"></span><span id="newUniqueName"><span class="annot"><span class="annottext">newUniqueName :: String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#newUniqueName"><span class="hs-identifier hs-var hs-var">newUniqueName</span></a></span></span><span> </span><span id="local-6989586621679411136"><span class="annot"><span class="annottext">str :: String
</span><a href="#local-6989586621679411136"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-74"></span><span>  </span><span id="local-6989586621679411135"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411135"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; q Name
forall (m :: * -&gt; *). Quasi m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">qNewName</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411136"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-75"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; q Name
forall (m :: * -&gt; *). Quasi m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">qNewName</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; q Name) -&gt; String -&gt; q Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411135"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="hs-comment">-- | @mkNameWith lookup_fun mkName_fun str@ looks up the exact 'Name' of @str@</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- using the function @lookup_fun@. If it finds 'Just' the 'Name', meaning</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- that it is bound in the current scope, then it is returned. If it finds</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- 'Nothing', it assumes that @str@ is declared in the current module, and</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- uses @mkName_fun@ to construct the appropriate 'Name' to return.</span><span>
</span><span id="line-82"></span><span id="local-6989586621679411352"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkNameWith"><span class="hs-identifier hs-type">mkNameWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679411352"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411352"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>                      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-84"></span><span>                      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411352"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span></span><span>
</span><span id="line-85"></span><span id="mkNameWith"><span class="annot"><span class="annottext">mkNameWith :: (String -&gt; q (Maybe Name))
-&gt; (String -&gt; String -&gt; String -&gt; Name) -&gt; String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkNameWith"><span class="hs-identifier hs-var hs-var">mkNameWith</span></a></span></span><span> </span><span id="local-6989586621679411132"><span class="annot"><span class="annottext">lookup_fun :: String -&gt; q (Maybe Name)
</span><a href="#local-6989586621679411132"><span class="hs-identifier hs-var">lookup_fun</span></a></span></span><span> </span><span id="local-6989586621679411131"><span class="annot"><span class="annottext">mkName_fun :: String -&gt; String -&gt; String -&gt; Name
</span><a href="#local-6989586621679411131"><span class="hs-identifier hs-var">mkName_fun</span></a></span></span><span> </span><span id="local-6989586621679411130"><span class="annot"><span class="annottext">str :: String
</span><a href="#local-6989586621679411130"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-86"></span><span>  </span><span id="local-6989586621679411129"><span class="annot"><span class="annottext">Maybe Name
</span><a href="#local-6989586621679411129"><span class="hs-identifier hs-var">m_name</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; q (Maybe Name)
</span><a href="#local-6989586621679411132"><span class="hs-identifier hs-var">lookup_fun</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411130"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe Name
</span><a href="#local-6989586621679411129"><span class="hs-identifier hs-var">m_name</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679411128"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679411128"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; q Name
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411128"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-89"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-90"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Loc</span></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">loc_package :: Loc -&gt; String
</span><span class="hs-identifier hs-var">loc_package</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679411125"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411125"><span class="hs-identifier hs-var">pkg</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">loc_module :: Loc -&gt; String
</span><span class="hs-identifier hs-var">loc_module</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679411123"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411123"><span class="hs-identifier hs-var">modu</span></a></span></span><span> </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">q Loc
forall (m :: * -&gt; *). Quasi m =&gt; m Loc
</span><span class="hs-identifier hs-var">qLocation</span></span><span>
</span><span id="line-91"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; q Name
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; q Name) -&gt; Name -&gt; q Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String -&gt; Name
</span><a href="#local-6989586621679411131"><span class="hs-identifier hs-var">mkName_fun</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411125"><span class="hs-identifier hs-var">pkg</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411123"><span class="hs-identifier hs-var">modu</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411130"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span class="hs-comment">-- | Like TH's @lookupTypeName@, but if this name is not bound, then we assume</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- it is declared in the current module.</span><span>
</span><span id="line-95"></span><span id="local-6989586621679411121"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkTypeName"><span class="hs-identifier hs-type">mkTypeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679411121"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411121"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span></span><span>
</span><span id="line-96"></span><span id="mkTypeName"><span class="annot"><span class="annottext">mkTypeName :: String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkTypeName"><span class="hs-identifier hs-var hs-var">mkTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; q (Maybe Name))
-&gt; (String -&gt; String -&gt; String -&gt; Name) -&gt; String -&gt; q Name
forall (q :: * -&gt; *).
Quasi q =&gt;
(String -&gt; q (Maybe Name))
-&gt; (String -&gt; String -&gt; String -&gt; Name) -&gt; String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkNameWith"><span class="hs-identifier hs-var">mkNameWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; String -&gt; q (Maybe Name)
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; String -&gt; m (Maybe Name)
</span><span class="hs-identifier hs-var">qLookupName</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String -&gt; Name
</span><span class="hs-identifier hs-var">mkNameG_tc</span></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- | Like TH's @lookupDataName@, but if this name is not bound, then we assume</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- it is declared in the current module.</span><span>
</span><span id="line-100"></span><span id="local-6989586621679411119"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkDataName"><span class="hs-identifier hs-type">mkDataName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679411119"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411119"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span></span><span>
</span><span id="line-101"></span><span id="mkDataName"><span class="annot"><span class="annottext">mkDataName :: String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkDataName"><span class="hs-identifier hs-var hs-var">mkDataName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; q (Maybe Name))
-&gt; (String -&gt; String -&gt; String -&gt; Name) -&gt; String -&gt; q Name
forall (q :: * -&gt; *).
Quasi q =&gt;
(String -&gt; q (Maybe Name))
-&gt; (String -&gt; String -&gt; String -&gt; Name) -&gt; String -&gt; q Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkNameWith"><span class="hs-identifier hs-var">mkNameWith</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; String -&gt; q (Maybe Name)
forall (m :: * -&gt; *). Quasi m =&gt; Bool -&gt; String -&gt; m (Maybe Name)
</span><span class="hs-identifier hs-var">qLookupName</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String -&gt; Name
</span><span class="hs-identifier hs-var">mkNameG_d</span></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="hs-comment">-- | Is this name a data constructor name? A 'False' answer means &quot;unsure&quot;.</span><span>
</span><span id="line-104"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isDataName"><span class="hs-identifier hs-type">isDataName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-105"></span><span id="isDataName"><span class="annot"><span class="annottext">isDataName :: Name -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.Util.html#isDataName"><span class="hs-identifier hs-var hs-var">isDataName</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NameG</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataName</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-106"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isDataName"><span class="hs-identifier hs-var">isDataName</span></a></span><span> </span><span class="hs-identifier">_</span><span>                             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="hs-comment">-- | Extracts the name out of a variable pattern, or returns @Nothing@</span><span>
</span><span id="line-109"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripVarP_maybe"><span class="hs-identifier hs-type">stripVarP_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pat</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-110"></span><span id="stripVarP_maybe"><span class="annot"><span class="annottext">stripVarP_maybe :: Pat -&gt; Maybe Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#stripVarP_maybe"><span class="hs-identifier hs-var hs-var">stripVarP_maybe</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarP</span></span><span> </span><span id="local-6989586621679411114"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679411114"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411114"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-111"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripVarP_maybe"><span class="hs-identifier hs-var">stripVarP_maybe</span></a></span><span> </span><span class="hs-identifier">_</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Name
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-comment">-- | Extracts the name out of a @PlainTV@, or returns @Nothing@</span><span>
</span><span id="line-114"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripPlainTV_maybe"><span class="hs-identifier hs-type">stripPlainTV_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-115"></span><span id="stripPlainTV_maybe"><span class="annot"><span class="annottext">stripPlainTV_maybe :: TyVarBndr -&gt; Maybe Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#stripPlainTV_maybe"><span class="hs-identifier hs-var hs-var">stripPlainTV_maybe</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span id="local-6989586621679411112"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679411112"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411112"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-116"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#stripPlainTV_maybe"><span class="hs-identifier hs-var">stripPlainTV_maybe</span></a></span><span> </span><span class="hs-identifier">_</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Name
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | Report that a certain TH construct is impossible</span><span>
</span><span id="line-119"></span><span id="local-6989586621679411110"><span id="local-6989586621679411111"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#impossible"><span class="hs-identifier hs-type">impossible</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679411111"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411111"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679411110"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-120"></span><span id="impossible"><span class="annot"><span class="annottext">impossible :: String -&gt; q a
</span><a href="Language.Haskell.TH.Desugar.Util.html#impossible"><span class="hs-identifier hs-var hs-var">impossible</span></a></span></span><span> </span><span id="local-6989586621679411109"><span class="annot"><span class="annottext">err :: String
</span><a href="#local-6989586621679411109"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">Fail.fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411109"><span class="hs-identifier hs-var">err</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;\n    This should not happen in Haskell.\n    Please email rae@cs.brynmawr.edu with your code if you see this.&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-121"></span><span>
</span><span id="line-122"></span><span class="hs-comment">-- | Convert a 'TyVarBndr' into a 'Type', dropping the kind signature</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- (if it has one).</span><span>
</span><span id="line-124"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToType"><span class="hs-identifier hs-type">tvbToType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-125"></span><span id="tvbToType"><span class="annot"><span class="annottext">tvbToType :: TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#tvbToType"><span class="hs-identifier hs-var hs-var">tvbToType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; (TyVarBndr -&gt; Name) -&gt; TyVarBndr -&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><span class="hs-identifier hs-var">tvName</span></span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span class="hs-comment">-- | Convert a 'TyVarBndr' into a 'Type', preserving the kind signature</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- (if it has one).</span><span>
</span><span id="line-129"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTypeWithSig"><span class="hs-identifier hs-type">tvbToTypeWithSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-130"></span><span id="tvbToTypeWithSig"><span class="annot"><span class="annottext">tvbToTypeWithSig :: TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTypeWithSig"><span class="hs-identifier hs-var hs-var">tvbToTypeWithSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span id="local-6989586621679411106"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679411106"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411106"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-131"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTypeWithSig"><span class="hs-identifier hs-var">tvbToTypeWithSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679411104"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679411104"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679411103"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679411103"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411104"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411103"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="hs-comment">-- | Convert a 'TyVarBndr' into a 'TypeArg' (specifically, a 'TANormal'),</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- preserving the kind signature (if it has one).</span><span>
</span><span id="line-135"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTANormalWithSig"><span class="hs-identifier hs-type">tvbToTANormalWithSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span>
</span><span id="line-136"></span><span id="tvbToTANormalWithSig"><span class="annot"><span class="annottext">tvbToTANormalWithSig :: TyVarBndr -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTANormalWithSig"><span class="hs-identifier hs-var hs-var">tvbToTANormalWithSig</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg) -&gt; (TyVarBndr -&gt; Type) -&gt; TyVarBndr -&gt; TypeArg
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#tvbToTypeWithSig"><span class="hs-identifier hs-var">tvbToTypeWithSig</span></a></span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-comment">-- | Do two names name the same thing?</span><span>
</span><span id="line-139"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#nameMatches"><span class="hs-identifier hs-type">nameMatches</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-140"></span><span id="nameMatches"><span class="annot"><span class="annottext">nameMatches :: Name -&gt; Name -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.Util.html#nameMatches"><span class="hs-identifier hs-var hs-var">nameMatches</span></a></span></span><span> </span><span id="local-6989586621679411100"><span class="annot"><span class="annottext">n1 :: Name
</span><a href="#local-6989586621679411100"><span class="hs-identifier hs-var">n1</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span id="local-6989586621679411099"><span class="annot"><span class="annottext">occ1 :: OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span></span><span> </span><span id="local-6989586621679411098"><span class="annot"><span class="annottext">flav1 :: NameFlavour
</span><a href="#local-6989586621679411098"><span class="hs-identifier hs-var">flav1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679411097"><span class="annot"><span class="annottext">n2 :: Name
</span><a href="#local-6989586621679411097"><span class="hs-identifier hs-var">n2</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span id="local-6989586621679411096"><span class="annot"><span class="annottext">occ2 :: OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span></span><span> </span><span id="local-6989586621679411095"><span class="annot"><span class="annottext">flav2 :: NameFlavour
</span><a href="#local-6989586621679411095"><span class="hs-identifier hs-var">flav2</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><span class="hs-identifier hs-var">NameS</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411098"><span class="hs-identifier hs-var">flav1</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><span class="hs-identifier hs-var">NameS</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411095"><span class="hs-identifier hs-var">flav2</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameQ</span></span><span> </span><span id="local-6989586621679411092"><span class="annot"><span class="annottext">mod1 :: ModName
</span><a href="#local-6989586621679411092"><span class="hs-identifier hs-var">mod1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411098"><span class="hs-identifier hs-var">flav1</span></a></span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameQ</span></span><span> </span><span id="local-6989586621679411091"><span class="annot"><span class="annottext">mod2 :: ModName
</span><a href="#local-6989586621679411091"><span class="hs-identifier hs-var">mod2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411095"><span class="hs-identifier hs-var">flav2</span></a></span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411092"><span class="hs-identifier hs-var">mod1</span></a></span><span> </span><span class="annot"><span class="annottext">ModName -&gt; ModName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411091"><span class="hs-identifier hs-var">mod2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameQ</span></span><span> </span><span id="local-6989586621679411089"><span class="annot"><span class="annottext">mod1 :: ModName
</span><a href="#local-6989586621679411089"><span class="hs-identifier hs-var">mod1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411098"><span class="hs-identifier hs-var">flav1</span></a></span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameG</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679411088"><span class="annot"><span class="annottext">mod2 :: ModName
</span><a href="#local-6989586621679411088"><span class="hs-identifier hs-var">mod2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411095"><span class="hs-identifier hs-var">flav2</span></a></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411089"><span class="hs-identifier hs-var">mod1</span></a></span><span> </span><span class="annot"><span class="annottext">ModName -&gt; ModName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411088"><span class="hs-identifier hs-var">mod2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameG</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679411087"><span class="annot"><span class="annottext">mod1 :: ModName
</span><a href="#local-6989586621679411087"><span class="hs-identifier hs-var">mod1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411098"><span class="hs-identifier hs-var">flav1</span></a></span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameQ</span></span><span> </span><span id="local-6989586621679411086"><span class="annot"><span class="annottext">mod2 :: ModName
</span><a href="#local-6989586621679411086"><span class="hs-identifier hs-var">mod2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameFlavour
</span><a href="#local-6989586621679411095"><span class="hs-identifier hs-var">flav2</span></a></span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411087"><span class="hs-identifier hs-var">mod1</span></a></span><span> </span><span class="annot"><span class="annottext">ModName -&gt; ModName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ModName
</span><a href="#local-6989586621679411086"><span class="hs-identifier hs-var">mod2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411099"><span class="hs-identifier hs-var">occ1</span></a></span><span> </span><span class="annot"><span class="annottext">OccName -&gt; OccName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">OccName
</span><a href="#local-6989586621679411096"><span class="hs-identifier hs-var">occ2</span></a></span><span>
</span><span id="line-152"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411100"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411097"><span class="hs-identifier hs-var">n2</span></a></span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="hs-comment">-- | Extract the degree of a tuple</span><span>
</span><span id="line-156"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleDegree_maybe"><span class="hs-identifier hs-type">tupleDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-157"></span><span id="tupleDegree_maybe"><span class="annot"><span class="annottext">tupleDegree_maybe :: String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#tupleDegree_maybe"><span class="hs-identifier hs-var hs-var">tupleDegree_maybe</span></a></span></span><span> </span><span id="local-6989586621679411085"><span class="annot"><span class="annottext">s :: String
</span><a href="#local-6989586621679411085"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-char">'('</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679411084"><span class="annot"><span class="annottext">s1 :: String
</span><a href="#local-6989586621679411084"><span class="hs-identifier hs-var">s1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411085"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679411083"><span class="annot"><span class="annottext">commas :: String
</span><a href="#local-6989586621679411083"><span class="hs-identifier hs-var">commas</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;)&quot;</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(String, String) -&gt; Maybe (String, String)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((String, String) -&gt; Maybe (String, String))
-&gt; (String, String) -&gt; Maybe (String, String)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; String -&gt; (String, String)
forall a. (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-char">','</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411084"><span class="hs-identifier hs-var">s1</span></a></span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679411081"><span class="annot"><span class="annottext">degree :: Int
</span><a href="#local-6989586621679411081"><span class="hs-identifier hs-var hs-var">degree</span></a></span></span><span>
</span><span id="line-161"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411083"><span class="hs-identifier hs-var">commas</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-162"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411083"><span class="hs-identifier hs-var">commas</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span>
</span><span id="line-163"></span><span>  </span><span class="annot"><span class="annottext">Int -&gt; Maybe Int
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679411081"><span class="hs-identifier hs-var">degree</span></a></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- | Extract the degree of a tuple name</span><span>
</span><span id="line-166"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#tupleNameDegree_maybe"><span class="hs-identifier hs-type">tupleNameDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-167"></span><span id="tupleNameDegree_maybe"><span class="annot"><span class="annottext">tupleNameDegree_maybe :: Name -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#tupleNameDegree_maybe"><span class="hs-identifier hs-var hs-var">tupleNameDegree_maybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#tupleDegree_maybe"><span class="hs-identifier hs-var">tupleDegree_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe Int) -&gt; (Name -&gt; String) -&gt; Name -&gt; Maybe Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="hs-comment">-- | Extract the degree of an unboxed sum</span><span>
</span><span id="line-170"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumDegree_maybe"><span class="hs-identifier hs-type">unboxedSumDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-171"></span><span id="unboxedSumDegree_maybe"><span class="annot"><span class="annottext">unboxedSumDegree_maybe :: String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumDegree_maybe"><span class="hs-identifier hs-var hs-var">unboxedSumDegree_maybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumTupleDegree_maybe"><span class="hs-identifier hs-var">unboxedSumTupleDegree_maybe</span></a></span><span> </span><span class="annot"><span class="hs-char">'|'</span></span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="hs-comment">-- | Extract the degree of an unboxed sum name</span><span>
</span><span id="line-174"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumNameDegree_maybe"><span class="hs-identifier hs-type">unboxedSumNameDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-175"></span><span id="unboxedSumNameDegree_maybe"><span class="annot"><span class="annottext">unboxedSumNameDegree_maybe :: Name -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumNameDegree_maybe"><span class="hs-identifier hs-var hs-var">unboxedSumNameDegree_maybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumDegree_maybe"><span class="hs-identifier hs-var">unboxedSumDegree_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe Int) -&gt; (Name -&gt; String) -&gt; Name -&gt; Maybe Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="hs-comment">-- | Extract the degree of an unboxed tuple</span><span>
</span><span id="line-178"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleDegree_maybe"><span class="hs-identifier hs-type">unboxedTupleDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-179"></span><span id="unboxedTupleDegree_maybe"><span class="annot"><span class="annottext">unboxedTupleDegree_maybe :: String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleDegree_maybe"><span class="hs-identifier hs-var hs-var">unboxedTupleDegree_maybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumTupleDegree_maybe"><span class="hs-identifier hs-var">unboxedSumTupleDegree_maybe</span></a></span><span> </span><span class="annot"><span class="hs-char">','</span></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- | Extract the degree of an unboxed sum or tuple</span><span>
</span><span id="line-182"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumTupleDegree_maybe"><span class="hs-identifier hs-type">unboxedSumTupleDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-183"></span><span id="unboxedSumTupleDegree_maybe"><span class="annot"><span class="annottext">unboxedSumTupleDegree_maybe :: Char -&gt; String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedSumTupleDegree_maybe"><span class="hs-identifier hs-var hs-var">unboxedSumTupleDegree_maybe</span></a></span></span><span> </span><span id="local-6989586621679411076"><span class="annot"><span class="annottext">sep :: Char
</span><a href="#local-6989586621679411076"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span id="local-6989586621679411075"><span class="annot"><span class="annottext">s :: String
</span><a href="#local-6989586621679411075"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-char">'('</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="hs-char">'#'</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679411074"><span class="annot"><span class="annottext">s1 :: String
</span><a href="#local-6989586621679411074"><span class="hs-identifier hs-var">s1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411075"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-185"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679411073"><span class="annot"><span class="annottext">seps :: String
</span><a href="#local-6989586621679411073"><span class="hs-identifier hs-var">seps</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;#)&quot;</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(String, String) -&gt; Maybe (String, String)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((String, String) -&gt; Maybe (String, String))
-&gt; (String, String) -&gt; Maybe (String, String)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; String -&gt; (String, String)
forall a. (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">span</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Char -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679411076"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411074"><span class="hs-identifier hs-var">s1</span></a></span><span>
</span><span id="line-186"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679411072"><span class="annot"><span class="annottext">degree :: Int
</span><a href="#local-6989586621679411072"><span class="hs-identifier hs-var hs-var">degree</span></a></span></span><span>
</span><span id="line-187"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411073"><span class="hs-identifier hs-var">seps</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-number">0</span></span><span>
</span><span id="line-188"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411073"><span class="hs-identifier hs-var">seps</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span>
</span><span id="line-189"></span><span>  </span><span class="annot"><span class="annottext">Int -&gt; Maybe Int
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679411072"><span class="hs-identifier hs-var">degree</span></a></span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span class="hs-comment">-- | Extract the degree of an unboxed tuple name</span><span>
</span><span id="line-192"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleNameDegree_maybe"><span class="hs-identifier hs-type">unboxedTupleNameDegree_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-193"></span><span id="unboxedTupleNameDegree_maybe"><span class="annot"><span class="annottext">unboxedTupleNameDegree_maybe :: Name -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleNameDegree_maybe"><span class="hs-identifier hs-var hs-var">unboxedTupleNameDegree_maybe</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#unboxedTupleDegree_maybe"><span class="hs-identifier hs-var">unboxedTupleDegree_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe Int) -&gt; (Name -&gt; String) -&gt; Name -&gt; Maybe Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span class="hs-comment">-- | If the argument is a tuple type, return the components</span><span>
</span><span id="line-196"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitTuple_maybe"><span class="hs-identifier hs-type">splitTuple_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-197"></span><span id="splitTuple_maybe"><span class="annot"><span class="annottext">splitTuple_maybe :: Type -&gt; Maybe [Type]
</span><a href="Language.Haskell.TH.Desugar.Util.html#splitTuple_maybe"><span class="hs-identifier hs-var hs-var">splitTuple_maybe</span></a></span></span><span> </span><span id="local-6989586621679411071"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411071"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Maybe [Type]
</span><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411071"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-198"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679411070"><span class="annot"><span class="annottext">go :: [Type] -&gt; Type -&gt; Maybe [Type]
</span><a href="#local-6989586621679411070"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679411069"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679411069"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679411068"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679411068"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679411066"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679411066"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Maybe [Type]
</span><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411066"><span class="hs-identifier hs-var">t2</span></a></span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411069"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411068"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-199"></span><span>        </span><span class="annot"><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679411065"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679411065"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679411064"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679411064"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`SigT`</span></span><span> </span><span id="local-6989586621679411063"><span class="annot"><span class="annottext">_k :: Type
</span><a href="#local-6989586621679411063"><span class="hs-identifier hs-var">_k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Type -&gt; Maybe [Type]
</span><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411065"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411064"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-200"></span><span>        </span><span class="annot"><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679411062"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679411062"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679411060"><span class="annot"><span class="annottext">con_name :: Name
</span><a href="#local-6989586621679411060"><span class="hs-identifier hs-var">con_name</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679411059"><span class="annot"><span class="annottext">degree :: Int
</span><a href="#local-6989586621679411059"><span class="hs-identifier hs-var">degree</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Int
</span><a href="Language.Haskell.TH.Desugar.Util.html#tupleNameDegree_maybe"><span class="hs-identifier hs-var">tupleNameDegree_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411060"><span class="hs-identifier hs-var">con_name</span></a></span><span>
</span><span id="line-202"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411062"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679411059"><span class="hs-identifier hs-var">degree</span></a></span><span>
</span><span id="line-203"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Maybe [Type]
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411062"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-204"></span><span>        </span><span class="annot"><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679411058"><span class="annot"><span class="annottext">args :: [Type]
</span><a href="#local-6989586621679411058"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TupleT</span></span><span> </span><span id="local-6989586621679411056"><span class="annot"><span class="annottext">degree :: Int
</span><a href="#local-6989586621679411056"><span class="hs-identifier hs-var">degree</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411058"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679411056"><span class="hs-identifier hs-var">degree</span></a></span><span>
</span><span id="line-206"></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; Maybe [Type]
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411058"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-207"></span><span>        </span><span class="annot"><a href="#local-6989586621679411070"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe [Type]
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span class="hs-comment">-- | Like 'mkExtraDKindBinders', but parameterized to allow working over both</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- 'Kind'/'TyVarBndr' and 'DKind'/'DTyVarBndr'.</span><span>
</span><span id="line-211"></span><span id="local-6989586621679411052"><span id="local-6989586621679411053"><span id="local-6989586621679411054"><span id="local-6989586621679411055"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mkExtraKindBindersGeneric"><span class="hs-identifier hs-type">mkExtraKindBindersGeneric</span></a></span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="annot"><a href="#local-6989586621679411055"><span class="hs-identifier hs-type">q</span></a></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411054"><span class="hs-identifier hs-type">kind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411053"><span class="hs-identifier hs-type">tyVarBndr</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411052"><span class="hs-identifier hs-type">pred</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411054"><span class="hs-identifier hs-type">kind</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679411054"><span class="hs-identifier hs-type">kind</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411054"><span class="hs-identifier hs-type">kind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411053"><span class="hs-identifier hs-type">tyVarBndr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411054"><span class="hs-identifier hs-type">kind</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411055"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411053"><span class="hs-identifier hs-type">tyVarBndr</span></a></span><span class="hs-special">]</span></span></span></span></span><span>
</span><span id="line-216"></span><span id="mkExtraKindBindersGeneric"><span class="annot"><span class="annottext">mkExtraKindBindersGeneric :: (kind -&gt; ([tyVarBndr], [pred], [kind], kind))
-&gt; (Name -&gt; kind -&gt; tyVarBndr) -&gt; kind -&gt; q [tyVarBndr]
</span><a href="Language.Haskell.TH.Desugar.Util.html#mkExtraKindBindersGeneric"><span class="hs-identifier hs-var hs-var">mkExtraKindBindersGeneric</span></a></span></span><span> </span><span id="local-6989586621679411051"><span class="annot"><span class="annottext">unravel :: kind -&gt; ([tyVarBndr], [pred], [kind], kind)
</span><a href="#local-6989586621679411051"><span class="hs-identifier hs-var">unravel</span></a></span></span><span> </span><span id="local-6989586621679411050"><span class="annot"><span class="annottext">mkKindedTV :: Name -&gt; kind -&gt; tyVarBndr
</span><a href="#local-6989586621679411050"><span class="hs-identifier hs-var">mkKindedTV</span></a></span></span><span> </span><span id="local-6989586621679411049"><span class="annot"><span class="annottext">k :: kind
</span><a href="#local-6989586621679411049"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411048"><span class="annot"><span class="annottext">args :: [kind]
</span><a href="#local-6989586621679411048"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">kind -&gt; ([tyVarBndr], [pred], [kind], kind)
</span><a href="#local-6989586621679411051"><span class="hs-identifier hs-var">unravel</span></a></span><span> </span><span class="annot"><span class="annottext">kind
</span><a href="#local-6989586621679411049"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-218"></span><span>  </span><span id="local-6989586621679411047"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679411047"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int -&gt; q Name -&gt; q [Name]
forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m [a]
</span><span class="hs-identifier hs-var">replicateM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[kind] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[kind]
</span><a href="#local-6989586621679411048"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; q Name
forall (m :: * -&gt; *). Quasi m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">qNewName</span></span><span> </span><span class="annot"><span class="hs-string">&quot;a&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span>  </span><span class="annot"><span class="annottext">[tyVarBndr] -&gt; q [tyVarBndr]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; kind -&gt; tyVarBndr) -&gt; [Name] -&gt; [kind] -&gt; [tyVarBndr]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; kind -&gt; tyVarBndr
</span><a href="#local-6989586621679411050"><span class="hs-identifier hs-var">mkKindedTV</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679411047"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">[kind]
</span><a href="#local-6989586621679411048"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="hs-comment">-- | Decompose a function 'Type' into its type variables, its context, its</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- argument types, and its result type.</span><span>
</span><span id="line-223"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-type">unravelType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-224"></span><span id="unravelType"><span class="annot"><span class="annottext">unravelType :: Type -&gt; ([TyVarBndr], [Type], [Type], Type)
</span><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-var hs-var">unravelType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679411044"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679411044"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679411043"><span class="annot"><span class="annottext">cxt :: [Type]
</span><a href="#local-6989586621679411043"><span class="hs-identifier hs-var">cxt</span></a></span></span><span> </span><span id="local-6989586621679411042"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679411042"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679411041"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndr]
</span><a href="#local-6989586621679411041"><span class="hs-identifier hs-var">tvbs'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411040"><span class="annot"><span class="annottext">cxt' :: [Type]
</span><a href="#local-6989586621679411040"><span class="hs-identifier hs-var">cxt'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411039"><span class="annot"><span class="annottext">tys :: [Type]
</span><a href="#local-6989586621679411039"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411038"><span class="annot"><span class="annottext">res :: Type
</span><a href="#local-6989586621679411038"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndr], [Type], [Type], Type)
</span><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411042"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679411044"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679411041"><span class="hs-identifier hs-var">tvbs'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411043"><span class="hs-identifier hs-var">cxt</span></a></span><span> </span><span class="annot"><span class="annottext">[Type] -&gt; [Type] -&gt; [Type]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411040"><span class="hs-identifier hs-var">cxt'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411039"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411038"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-227"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ArrowT</span></span><span> </span><span id="local-6989586621679411036"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679411036"><span class="hs-identifier hs-var">t1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679411035"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679411035"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-228"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679411034"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679411034"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411033"><span class="annot"><span class="annottext">cxt :: [Type]
</span><a href="#local-6989586621679411033"><span class="hs-identifier hs-var">cxt</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411032"><span class="annot"><span class="annottext">tys :: [Type]
</span><a href="#local-6989586621679411032"><span class="hs-identifier hs-var">tys</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679411031"><span class="annot"><span class="annottext">res :: Type
</span><a href="#local-6989586621679411031"><span class="hs-identifier hs-var">res</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndr], [Type], [Type], Type)
</span><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411035"><span class="hs-identifier hs-var">t2</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679411034"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411033"><span class="hs-identifier hs-var">cxt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411036"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Type] -&gt; [Type]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411032"><span class="hs-identifier hs-var">tys</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411031"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unravelType"><span class="hs-identifier hs-var">unravelType</span></a></span><span> </span><span id="local-6989586621679411030"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411030"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411030"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-231"></span><span>
</span><span id="line-232"></span><span class="hs-comment">-- | Remove all of the explicit kind signatures from a 'Type'.</span><span>
</span><span id="line-233"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-type">unSigType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-234"></span><span id="unSigType"><span class="annot"><span class="annottext">unSigType :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var hs-var">unSigType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679411029"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411029"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411029"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-235"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679411028"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679411028"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679411027"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679411027"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411028"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411027"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679411026"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679411026"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679411025"><span class="annot"><span class="annottext">ctxt :: [Type]
</span><a href="#local-6989586621679411025"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679411024"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411024"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-237"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [Type] -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679411026"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; [Type] -&gt; [Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigPred"><span class="hs-identifier hs-var">unSigPred</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679411025"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411024"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679411021"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679411021"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679411020"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679411020"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679411019"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679411019"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">InfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411021"><span class="hs-identifier hs-var">t1</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411020"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411019"><span class="hs-identifier hs-var">t2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679411017"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679411017"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679411016"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679411016"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679411015"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679411015"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">UInfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411017"><span class="hs-identifier hs-var">t1</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679411016"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411015"><span class="hs-identifier hs-var">t2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-241"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679411013"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411013"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">ParensT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411013"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 807
</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679411011"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411011"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679411010"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679411010"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppKindT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411011"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411010"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-245"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679411008"><span class="annot"><span class="annottext">n :: String
</span><a href="#local-6989586621679411008"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679411007"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411007"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679411008"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411007"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span id="local-6989586621679411006"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679411006"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411006"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span class="hs-comment">-- | Remove all of the explicit kind signatures from a 'Pred'.</span><span>
</span><span id="line-250"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigPred"><span class="hs-identifier hs-type">unSigPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 710
</span><span id="unSigPred"><span class="annot"><span class="annottext">unSigPred :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigPred"><span class="hs-identifier hs-var hs-var">unSigPred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">unSigPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">tys</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">unSigType</span><span> </span><span class="hs-identifier">tys</span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span class="hs-identifier">unSigPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">unSigType</span><span> </span><span class="hs-identifier">t1</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">unSigType</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- | Decompose an applied type into its individual components. For example, this:</span><span>
</span><span id="line-259"></span><span class="hs-comment">--</span><span>
</span><span id="line-260"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-261"></span><span class="hs-comment">-- Proxy \@Type Char</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-263"></span><span class="hs-comment">--</span><span>
</span><span id="line-264"></span><span class="hs-comment">-- would be unfolded to this:</span><span>
</span><span id="line-265"></span><span class="hs-comment">--</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- ('ConT' ''Proxy, ['TyArg' ('ConT' ''Type), 'TANormal' ('ConT' ''Char)])</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-269"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unfoldType"><span class="hs-identifier hs-type">unfoldType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span id="unfoldType"><span class="annot"><span class="annottext">unfoldType :: Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Desugar.Util.html#unfoldType"><span class="hs-identifier hs-var hs-var">unfoldType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-271"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-272"></span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>    </span><span id="local-6989586621679411005"><span class="annot"><span class="annottext">go :: [TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679411004"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679411004"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679411003"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679411003"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679411004"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411003"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-274"></span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679411002"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679411002"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679411001"><span class="annot"><span class="annottext">ty1 :: Type
</span><a href="#local-6989586621679411001"><span class="hs-identifier hs-var">ty1</span></a></span></span><span> </span><span id="local-6989586621679411000"><span class="annot"><span class="annottext">ty2 :: Type
</span><a href="#local-6989586621679411000"><span class="hs-identifier hs-var">ty2</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411000"><span class="hs-identifier hs-var">ty2</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679411002"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679411001"><span class="hs-identifier hs-var">ty1</span></a></span><span>
</span><span id="line-275"></span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679410999"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679410999"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679410998"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679410998"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679410999"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410998"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679410997"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679410997"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679410996"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679410996"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679410997"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410996"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 807
</span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679410995"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679410995"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679410994"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679410994"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621679410993"><span class="annot"><span class="annottext">ki :: Type
</span><a href="#local-6989586621679410993"><span class="hs-identifier hs-var">ki</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410993"><span class="hs-identifier hs-var">ki</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679410995"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410994"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><a href="#local-6989586621679411005"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679410991"><span class="annot"><span class="annottext">acc :: [TypeArg]
</span><a href="#local-6989586621679410991"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span id="local-6989586621679410990"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679410990"><span class="hs-identifier hs-var">ty</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410990"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679410991"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>
</span><span id="line-284"></span><span class="hs-comment">-- | An argument to a type, either a normal type ('TANormal') or a visible</span><span>
</span><span id="line-285"></span><span class="hs-comment">-- kind application ('TyArg').</span><span>
</span><span id="line-286"></span><span class="hs-comment">--</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- 'TypeArg' is useful when decomposing an application of a 'Type' to its</span><span>
</span><span id="line-288"></span><span class="hs-comment">-- arguments (e.g., in 'unfoldType').</span><span>
</span><span id="line-289"></span><span class="hs-keyword">data</span><span> </span><span id="TypeArg"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-var">TypeArg</span></a></span></span><span>
</span><span id="line-290"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TANormal"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyArg"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410985"><span id="local-6989586621679410987"><span class="annot"><span class="annottext">TypeArg -&gt; TypeArg -&gt; Bool
(TypeArg -&gt; TypeArg -&gt; Bool)
-&gt; (TypeArg -&gt; TypeArg -&gt; Bool) -&gt; Eq TypeArg
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: TypeArg -&gt; TypeArg -&gt; Bool
$c/= :: TypeArg -&gt; TypeArg -&gt; Bool
== :: TypeArg -&gt; TypeArg -&gt; Bool
$c== :: TypeArg -&gt; TypeArg -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410978"><span id="local-6989586621679410980"><span id="local-6989586621679410982"><span class="annot"><span class="annottext">Int -&gt; TypeArg -&gt; String -&gt; String
[TypeArg] -&gt; String -&gt; String
TypeArg -&gt; String
(Int -&gt; TypeArg -&gt; String -&gt; String)
-&gt; (TypeArg -&gt; String)
-&gt; ([TypeArg] -&gt; String -&gt; String)
-&gt; Show TypeArg
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
showList :: [TypeArg] -&gt; String -&gt; String
$cshowList :: [TypeArg] -&gt; String -&gt; String
show :: TypeArg -&gt; String
$cshow :: TypeArg -&gt; String
showsPrec :: Int -&gt; TypeArg -&gt; String -&gt; String
$cshowsPrec :: Int -&gt; TypeArg -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cTyArg"><span id="%24cTANormal"><span id="%24tTypeArg"><span id="local-6989586621679410948"><span id="local-6989586621679410950"><span id="local-6989586621679410952"><span id="local-6989586621679410954"><span id="local-6989586621679410956"><span id="local-6989586621679410958"><span id="local-6989586621679410960"><span id="local-6989586621679410962"><span id="local-6989586621679410964"><span id="local-6989586621679410966"><span id="local-6989586621679410968"><span id="local-6989586621679410970"><span id="local-6989586621679410972"><span id="local-6989586621679410974"><span class="annot"><span class="annottext">Typeable TypeArg
DataType
Constr
Typeable TypeArg =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; TypeArg -&gt; c TypeArg)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeArg)
-&gt; (TypeArg -&gt; Constr)
-&gt; (TypeArg -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeArg))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TypeArg))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; TypeArg -&gt; TypeArg)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg)
-&gt; Data TypeArg
TypeArg -&gt; DataType
TypeArg -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; TypeArg -&gt; TypeArg
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeArg -&gt; c TypeArg
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeArg
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeArg
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeArg -&gt; c TypeArg
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeArg)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TypeArg)
$cTyArg :: Constr
$cTANormal :: Constr
$tTypeArg :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TypeArg -&gt; m TypeArg
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TypeArg -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TypeArg -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TypeArg -&gt; TypeArg
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TypeArg -&gt; TypeArg
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TypeArg)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TypeArg)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeArg)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TypeArg)
dataTypeOf :: TypeArg -&gt; DataType
$cdataTypeOf :: TypeArg -&gt; DataType
toConstr :: TypeArg -&gt; Constr
$ctoConstr :: TypeArg -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeArg
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TypeArg
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeArg -&gt; c TypeArg
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TypeArg -&gt; c TypeArg
$cp1Data :: Typeable TypeArg
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span class="hs-comment">-- | Apply one 'Type' to a list of arguments.</span><span>
</span><span id="line-295"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#applyType"><span class="hs-identifier hs-type">applyType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-296"></span><span id="applyType"><span class="annot"><span class="annottext">applyType :: Type -&gt; [TypeArg] -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#applyType"><span class="hs-identifier hs-var hs-var">applyType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg -&gt; Type) -&gt; Type -&gt; [TypeArg] -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg -&gt; Type
</span><a href="#local-6989586621679410943"><span class="hs-identifier hs-var">apply</span></a></span><span>
</span><span id="line-297"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-298"></span><span>    </span><span class="annot"><a href="#local-6989586621679410943"><span class="hs-identifier hs-type">apply</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-299"></span><span>    </span><span id="local-6989586621679410943"><span class="annot"><span class="annottext">apply :: Type -&gt; TypeArg -&gt; Type
</span><a href="#local-6989586621679410943"><span class="hs-identifier hs-var hs-var">apply</span></a></span></span><span> </span><span id="local-6989586621679410942"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679410942"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679410941"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679410941"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410942"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410941"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-300"></span><span>    </span><span class="annot"><a href="#local-6989586621679410943"><span class="hs-identifier hs-var">apply</span></a></span><span> </span><span id="local-6989586621679410940"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679410940"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679410939"><span class="annot"><span class="annottext">_x :: Type
</span><a href="#local-6989586621679410939"><span class="hs-identifier hs-var">_x</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 807
</span><span>                           </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410940"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppKindT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410939"><span class="hs-identifier hs-var">_x</span></a></span><span class="hs-cpp">
#else
</span><span>                           </span><span class="hs-comment">-- VKA isn't supported, so</span><span>
</span><span id="line-305"></span><span>                           </span><span class="hs-comment">-- conservatively drop the argument</span><span>
</span><span id="line-306"></span><span>                           </span><span class="hs-identifier">f</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-309"></span><span class="hs-comment">-- | Filter the normal type arguments from a list of 'TypeArg's.</span><span>
</span><span id="line-310"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#filterTANormals"><span class="hs-identifier hs-type">filterTANormals</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-311"></span><span id="filterTANormals"><span class="annot"><span class="annottext">filterTANormals :: [TypeArg] -&gt; [Type]
</span><a href="Language.Haskell.TH.Desugar.Util.html#filterTANormals"><span class="hs-identifier hs-var hs-var">filterTANormals</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TypeArg -&gt; Maybe Type) -&gt; [TypeArg] -&gt; [Type]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679410937"><span class="hs-identifier hs-var">getTANormal</span></a></span><span>
</span><span id="line-312"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-313"></span><span>    </span><span class="annot"><a href="#local-6989586621679410937"><span class="hs-identifier hs-type">getTANormal</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-314"></span><span>    </span><span id="local-6989586621679410937"><span class="annot"><span class="annottext">getTANormal :: TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679410937"><span class="hs-identifier hs-var hs-var">getTANormal</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679410936"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679410936"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410936"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-315"></span><span>    </span><span class="annot"><a href="#local-6989586621679410937"><span class="hs-identifier hs-var">getTANormal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-316"></span><span>
</span><span id="line-317"></span><span class="hs-comment">-- | Remove all of the explicit kind signatures from a 'TypeArg'.</span><span>
</span><span id="line-318"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigTypeArg"><span class="hs-identifier hs-type">unSigTypeArg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span>
</span><span id="line-319"></span><span id="unSigTypeArg"><span class="annot"><span class="annottext">unSigTypeArg :: TypeArg -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigTypeArg"><span class="hs-identifier hs-var hs-var">unSigTypeArg</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679410935"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679410935"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410935"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#unSigTypeArg"><span class="hs-identifier hs-var">unSigTypeArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679410934"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679410934"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#unSigType"><span class="hs-identifier hs-var">unSigType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410934"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span class="hs-comment">-- | Extract the underlying 'Type' or 'Kind' from a 'TypeArg'. This forgets</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- information about whether a type is a normal argument or not, so use with</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- caution.</span><span>
</span><span id="line-325"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#probablyWrongUnTypeArg"><span class="hs-identifier hs-type">probablyWrongUnTypeArg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-326"></span><span id="probablyWrongUnTypeArg"><span class="annot"><span class="annottext">probablyWrongUnTypeArg :: TypeArg -&gt; Type
</span><a href="Language.Haskell.TH.Desugar.Util.html#probablyWrongUnTypeArg"><span class="hs-identifier hs-var hs-var">probablyWrongUnTypeArg</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679410933"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679410933"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410933"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-327"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#probablyWrongUnTypeArg"><span class="hs-identifier hs-var">probablyWrongUnTypeArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679410932"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679410932"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679410932"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="hs-comment">----------------------------------------</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- Free names, etc.</span><span>
</span><span id="line-331"></span><span class="hs-comment">----------------------------------------</span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span class="hs-comment">-- | Check if a name occurs anywhere within a TH tree.</span><span>
</span><span id="line-334"></span><span id="local-6989586621679410931"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#nameOccursIn"><span class="hs-identifier hs-type">nameOccursIn</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679410931"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410931"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-335"></span><span id="nameOccursIn"><span class="annot"><span class="annottext">nameOccursIn :: Name -&gt; a -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.Util.html#nameOccursIn"><span class="hs-identifier hs-var hs-var">nameOccursIn</span></a></span></span><span> </span><span id="local-6989586621679410930"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679410930"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool -&gt; Bool) -&gt; GenericQ Bool -&gt; GenericQ Bool
forall r. (r -&gt; r -&gt; r) -&gt; GenericQ r -&gt; GenericQ r
</span><span class="hs-identifier hs-var">everything</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">(||)</span></span><span> </span><span class="annot"><span class="annottext">(GenericQ Bool -&gt; a -&gt; Bool) -&gt; GenericQ Bool -&gt; a -&gt; Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; (Name -&gt; Bool) -&gt; a -&gt; Bool
forall a b r. (Typeable a, Typeable b) =&gt; r -&gt; (b -&gt; r) -&gt; a -&gt; r
</span><span class="hs-identifier hs-var">mkQ</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679410930"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span class="hs-comment">-- | Extract all Names mentioned in a TH tree.</span><span>
</span><span id="line-338"></span><span id="local-6989586621679410926"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#allNamesIn"><span class="hs-identifier hs-type">allNamesIn</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679410926"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410926"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span></span><span>
</span><span id="line-339"></span><span id="allNamesIn"><span class="annot"><span class="annottext">allNamesIn :: a -&gt; [Name]
</span><a href="Language.Haskell.TH.Desugar.Util.html#allNamesIn"><span class="hs-identifier hs-var hs-var">allNamesIn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name] -&gt; [Name]) -&gt; GenericQ [Name] -&gt; GenericQ [Name]
forall r. (r -&gt; r -&gt; r) -&gt; GenericQ r -&gt; GenericQ r
</span><span class="hs-identifier hs-var">everything</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">(++)</span></span><span> </span><span class="annot"><span class="annottext">(GenericQ [Name] -&gt; a -&gt; [Name]) -&gt; GenericQ [Name] -&gt; a -&gt; [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; (Name -&gt; [Name]) -&gt; a -&gt; [Name]
forall a b r. (Typeable a, Typeable b) =&gt; r -&gt; (b -&gt; r) -&gt; a -&gt; r
</span><span class="hs-identifier hs-var">mkQ</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="hs-comment">-- | Extract the names bound in a @Stmt@</span><span>
</span><span id="line-342"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-type">extractBoundNamesStmt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Stmt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html#OSet"><span class="hs-identifier hs-type">OSet</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-343"></span><span id="extractBoundNamesStmt"><span class="annot"><span class="annottext">extractBoundNamesStmt :: Stmt -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var hs-var">extractBoundNamesStmt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">BindS</span></span><span> </span><span id="local-6989586621679410924"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410924"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410924"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-344"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">LetS</span></span><span> </span><span id="local-6989586621679410922"><span class="annot"><span class="annottext">decs :: [Dec]
</span><a href="#local-6989586621679410922"><span class="hs-identifier hs-var">decs</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; OSet Name) -&gt; [Dec] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Dec -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier hs-var">extractBoundNamesDec</span></a></span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679410922"><span class="hs-identifier hs-var">decs</span></a></span><span>
</span><span id="line-345"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NoBindS</span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OSet Name
forall a. OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#empty"><span class="hs-identifier hs-var">OS.empty</span></a></span><span>
</span><span id="line-346"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParS</span></span><span> </span><span id="local-6989586621679410917"><span class="annot"><span class="annottext">stmtss :: [[Stmt]]
</span><a href="#local-6989586621679410917"><span class="hs-identifier hs-var">stmtss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Stmt] -&gt; OSet Name) -&gt; [[Stmt]] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Stmt -&gt; OSet Name) -&gt; [Stmt] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Stmt -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[[Stmt]]
</span><a href="#local-6989586621679410917"><span class="hs-identifier hs-var">stmtss</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 807
</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">RecS</span></span><span> </span><span id="local-6989586621679410915"><span class="annot"><span class="annottext">stmtss :: [Stmt]
</span><a href="#local-6989586621679410915"><span class="hs-identifier hs-var">stmtss</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Stmt -&gt; OSet Name) -&gt; [Stmt] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Stmt -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesStmt"><span class="hs-identifier hs-var">extractBoundNamesStmt</span></a></span><span> </span><span class="annot"><span class="annottext">[Stmt]
</span><a href="#local-6989586621679410915"><span class="hs-identifier hs-var">stmtss</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- | Extract the names bound in a @Dec@ that could appear in a @let@ expression.</span><span>
</span><span id="line-352"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier hs-type">extractBoundNamesDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html#OSet"><span class="hs-identifier hs-type">OSet</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-353"></span><span id="extractBoundNamesDec"><span class="annot"><span class="annottext">extractBoundNamesDec :: Dec -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier hs-var hs-var">extractBoundNamesDec</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">FunD</span></span><span> </span><span id="local-6989586621679410913"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679410913"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; OSet Name
forall a. a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#singleton"><span class="hs-identifier hs-var">OS.singleton</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679410913"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-354"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier hs-var">extractBoundNamesDec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ValD</span></span><span> </span><span id="local-6989586621679410910"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410910"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410910"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-355"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesDec"><span class="hs-identifier hs-var">extractBoundNamesDec</span></a></span><span> </span><span class="hs-identifier">_</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OSet Name
forall a. OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#empty"><span class="hs-identifier hs-var">OS.empty</span></a></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span class="hs-comment">-- | Extract the names bound in a @Pat@</span><span>
</span><span id="line-358"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-type">extractBoundNamesPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pat</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Desugar.OSet.html#OSet"><span class="hs-identifier hs-type">OSet</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-359"></span><span id="extractBoundNamesPat"><span class="annot"><span class="annottext">extractBoundNamesPat :: Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var hs-var">extractBoundNamesPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">LitP</span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OSet Name
forall a. OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#empty"><span class="hs-identifier hs-var">OS.empty</span></a></span><span>
</span><span id="line-360"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarP</span></span><span> </span><span id="local-6989586621679410908"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679410908"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; OSet Name
forall a. a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#singleton"><span class="hs-identifier hs-var">OS.singleton</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679410908"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-361"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TupP</span></span><span> </span><span id="local-6989586621679410906"><span class="annot"><span class="annottext">pats :: [Pat]
</span><a href="#local-6989586621679410906"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Pat -&gt; OSet Name) -&gt; [Pat] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat]
</span><a href="#local-6989586621679410906"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-362"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UnboxedTupP</span></span><span> </span><span id="local-6989586621679410904"><span class="annot"><span class="annottext">pats :: [Pat]
</span><a href="#local-6989586621679410904"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Pat -&gt; OSet Name) -&gt; [Pat] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat]
</span><a href="#local-6989586621679410904"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-363"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConP</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410902"><span class="annot"><span class="annottext">pats :: [Pat]
</span><a href="#local-6989586621679410902"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Pat -&gt; OSet Name) -&gt; [Pat] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat]
</span><a href="#local-6989586621679410902"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-364"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixP</span></span><span> </span><span id="local-6989586621679410900"><span class="annot"><span class="annottext">p1 :: Pat
</span><a href="#local-6989586621679410900"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410899"><span class="annot"><span class="annottext">p2 :: Pat
</span><a href="#local-6989586621679410899"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410900"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; OSet Name -&gt; OSet Name
forall a. Ord a =&gt; OSet a -&gt; OSet a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#union"><span class="hs-operator hs-var">`OS.union`</span></a></span><span>
</span><span id="line-365"></span><span>                                             </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410899"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-366"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixP</span></span><span> </span><span id="local-6989586621679410896"><span class="annot"><span class="annottext">p1 :: Pat
</span><a href="#local-6989586621679410896"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410895"><span class="annot"><span class="annottext">p2 :: Pat
</span><a href="#local-6989586621679410895"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410896"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; OSet Name -&gt; OSet Name
forall a. Ord a =&gt; OSet a -&gt; OSet a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#union"><span class="hs-operator hs-var">`OS.union`</span></a></span><span>
</span><span id="line-367"></span><span>                                             </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410895"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-368"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensP</span></span><span> </span><span id="local-6989586621679410893"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410893"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410893"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-369"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TildeP</span></span><span> </span><span id="local-6989586621679410891"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410891"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410891"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-370"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">BangP</span></span><span> </span><span id="local-6989586621679410889"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410889"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410889"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-371"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AsP</span></span><span> </span><span id="local-6989586621679410887"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679410887"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679410886"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410886"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; OSet Name
forall a. a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#singleton"><span class="hs-identifier hs-var">OS.singleton</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679410887"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">OSet Name -&gt; OSet Name -&gt; OSet Name
forall a. Ord a =&gt; OSet a -&gt; OSet a -&gt; OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#union"><span class="hs-operator hs-var">`OS.union`</span></a></span><span>
</span><span id="line-372"></span><span>                                             </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410886"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-373"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">WildP</span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OSet Name
forall a. OSet a
</span><a href="Language.Haskell.TH.Desugar.OSet.html#empty"><span class="hs-identifier hs-var">OS.empty</span></a></span><span>
</span><span id="line-374"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">RecP</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410883"><span class="annot"><span class="annottext">field_pats :: [FieldPat]
</span><a href="#local-6989586621679410883"><span class="hs-identifier hs-var">field_pats</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410882"><span class="annot"><span class="annottext">pats :: [Pat]
</span><a href="#local-6989586621679410882"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FieldPat] -&gt; ([Name], [Pat])
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">[FieldPat]
</span><a href="#local-6989586621679410883"><span class="hs-identifier hs-var">field_pats</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-375"></span><span>                                             </span><span class="annot"><span class="annottext">(Pat -&gt; OSet Name) -&gt; [Pat] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat]
</span><a href="#local-6989586621679410882"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-376"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ListP</span></span><span> </span><span id="local-6989586621679410879"><span class="annot"><span class="annottext">pats :: [Pat]
</span><a href="#local-6989586621679410879"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Pat -&gt; OSet Name) -&gt; [Pat] -&gt; OSet Name
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">[Pat]
</span><a href="#local-6989586621679410879"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-377"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigP</span></span><span> </span><span id="local-6989586621679410877"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410877"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410877"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-378"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ViewP</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410875"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410875"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410875"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 801
</span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UnboxedSumP</span></span><span> </span><span id="local-6989586621679410873"><span class="annot"><span class="annottext">pat :: Pat
</span><a href="#local-6989586621679410873"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat -&gt; OSet Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#extractBoundNamesPat"><span class="hs-identifier hs-var">extractBoundNamesPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat
</span><a href="#local-6989586621679410873"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-383"></span><span class="hs-comment">----------------------------------------</span><span>
</span><span id="line-384"></span><span class="hs-comment">-- General utility</span><span>
</span><span id="line-385"></span><span class="hs-comment">----------------------------------------</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="hs-comment">-- dirty implementation of explicit-to-implicit conversion</span><span>
</span><span id="line-389"></span><span class="hs-keyword">newtype</span><span> </span><span id="MagicIP"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#MagicIP"><span class="hs-identifier hs-var">MagicIP</span></a></span></span><span> </span><span id="local-6989586621679411242"><span class="annot"><a href="#local-6989586621679411242"><span class="hs-identifier hs-type">name</span></a></span></span><span> </span><span id="local-6989586621679411241"><span class="annot"><a href="#local-6989586621679411241"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679411240"><span class="annot"><a href="#local-6989586621679411240"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="MagicIP"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#MagicIP"><span class="hs-identifier hs-var">MagicIP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IP</span></span><span> </span><span class="annot"><a href="#local-6989586621679411242"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679411241"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411240"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-390"></span><span>
</span><span id="line-391"></span><span class="hs-comment">-- | Get an implicit param constraint (@IP name a@, which is the desugared</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- form of @(?name :: a)@) from an explicit value.</span><span>
</span><span id="line-393"></span><span class="hs-comment">--</span><span>
</span><span id="line-394"></span><span class="hs-comment">-- This function is only available with GHC 8.0 or later.</span><span>
</span><span id="line-395"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#bindIP"><span class="hs-identifier hs-type">bindIP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679410871"><span class="annot"><a href="#local-6989586621679410871"><span class="hs-identifier hs-type">name</span></a></span></span><span> </span><span id="local-6989586621679410870"><span class="annot"><a href="#local-6989586621679410870"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679410869"><span class="annot"><a href="#local-6989586621679410869"><span class="hs-identifier hs-type">r</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="#local-6989586621679410870"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IP</span></span><span> </span><span class="annot"><a href="#local-6989586621679410871"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679410870"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410869"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410869"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-396"></span><span id="bindIP"><span class="annot"><span class="annottext">bindIP :: a -&gt; (IP name a =&gt; r) -&gt; r
</span><a href="Language.Haskell.TH.Desugar.Util.html#bindIP"><span class="hs-identifier hs-var hs-var">bindIP</span></a></span></span><span> </span><span id="local-6989586621679410868"><span class="annot"><span class="annottext">val :: a
</span><a href="#local-6989586621679410868"><span class="hs-identifier hs-var">val</span></a></span></span><span> </span><span id="local-6989586621679410867"><span class="annot"><span class="annottext">k :: IP name a =&gt; r
</span><a href="#local-6989586621679410867"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MagicIP name a r -&gt; a -&gt; r
forall a b. a -&gt; b
</span><span class="hs-identifier hs-var">unsafeCoerce</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(IP name a =&gt; r) -&gt; MagicIP name a r
forall (name :: Symbol) a r. (IP name a =&gt; r) -&gt; MagicIP name a r
</span><a href="Language.Haskell.TH.Desugar.Util.html#MagicIP"><span class="hs-identifier hs-var">MagicIP</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679410871"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="annot"><span class="annottext">IP name a =&gt; r
</span><a href="#local-6989586621679410867"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679410870"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410869"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679410868"><span class="hs-identifier hs-var">val</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-399"></span><span class="hs-comment">-- like GHC's</span><span>
</span><span id="line-400"></span><span id="local-6989586621679411236"><span id="local-6989586621679411237"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier hs-type">splitAtList</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411237"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411236"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411236"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411236"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-401"></span><span id="splitAtList"><span class="annot"><span class="annottext">splitAtList :: [a] -&gt; [b] -&gt; ([b], [b])
</span><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier hs-var hs-var">splitAtList</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621679410866"><span class="annot"><span class="annottext">x :: [b]
</span><a href="#local-6989586621679410866"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410866"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-402"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier hs-var">splitAtList</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679410865"><span class="annot"><span class="annottext">t :: [a]
</span><a href="#local-6989586621679410865"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410864"><span class="annot"><span class="annottext">x :: b
</span><a href="#local-6989586621679410864"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679410863"><span class="annot"><span class="annottext">xs :: [b]
</span><a href="#local-6989586621679410863"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-403"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410862"><span class="annot"><span class="annottext">as :: [b]
</span><a href="#local-6989586621679410862"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410861"><span class="annot"><span class="annottext">bs :: [b]
</span><a href="#local-6989586621679410861"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; [b] -&gt; ([b], [b])
forall a b. [a] -&gt; [b] -&gt; ([b], [b])
</span><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier hs-var">splitAtList</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679410865"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410863"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-404"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679410864"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; [b] -&gt; [b]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410862"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410861"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-405"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#splitAtList"><span class="hs-identifier hs-var">splitAtList</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span id="local-6989586621679410858"><span id="local-6989586621679410859"><span id="local-6989586621679410860"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#thdOf3"><span class="hs-identifier hs-type">thdOf3</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410860"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679410859"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679410858"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410858"><span class="hs-identifier hs-type">c</span></a></span></span></span></span><span>
</span><span id="line-408"></span><span id="thdOf3"><span class="annot"><span class="annottext">thdOf3 :: (a, b, c) -&gt; c
</span><a href="Language.Haskell.TH.Desugar.Util.html#thdOf3"><span class="hs-identifier hs-var hs-var">thdOf3</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679410857"><span class="annot"><span class="annottext">c :: c
</span><a href="#local-6989586621679410857"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679410857"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span id="local-6989586621679410853"><span id="local-6989586621679410854"><span id="local-6989586621679410855"><span id="local-6989586621679410856"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#thirdOf3"><span class="hs-identifier hs-type">thirdOf3</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410856"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410855"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410854"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679410853"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679410856"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410854"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679410853"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679410855"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-411"></span><span id="thirdOf3"><span class="annot"><span class="annottext">thirdOf3 :: (a -&gt; b) -&gt; (c, d, a) -&gt; (c, d, b)
</span><a href="Language.Haskell.TH.Desugar.Util.html#thirdOf3"><span class="hs-identifier hs-var hs-var">thirdOf3</span></a></span></span><span> </span><span id="local-6989586621679410852"><span class="annot"><span class="annottext">f :: a -&gt; b
</span><a href="#local-6989586621679410852"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410851"><span class="annot"><span class="annottext">c :: c
</span><a href="#local-6989586621679410851"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410850"><span class="annot"><span class="annottext">d :: d
</span><a href="#local-6989586621679410850"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410849"><span class="annot"><span class="annottext">a :: a
</span><a href="#local-6989586621679410849"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679410851"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679410850"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679410852"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679410849"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-412"></span><span>
</span><span id="line-413"></span><span class="hs-comment">-- lift concatMap into a monad</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- could this be more efficient?</span><span>
</span><span id="line-415"></span><span class="hs-comment">-- | Concatenate the result of a @mapM@</span><span>
</span><span id="line-416"></span><span id="local-6989586621679410845"><span id="local-6989586621679410846"><span id="local-6989586621679410847"><span id="local-6989586621679410848"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#concatMapM"><span class="hs-identifier hs-type">concatMapM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679410848"><span class="hs-identifier hs-type">monad</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679410847"><span class="hs-identifier hs-type">monoid</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Traversable</span></span><span> </span><span class="annot"><a href="#local-6989586621679410846"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-417"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410845"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410848"><span class="hs-identifier hs-type">monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679410847"><span class="hs-identifier hs-type">monoid</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410846"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679410845"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410848"><span class="hs-identifier hs-type">monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679410847"><span class="hs-identifier hs-type">monoid</span></a></span></span></span></span></span><span>
</span><span id="line-418"></span><span id="concatMapM"><span class="annot"><span class="annottext">concatMapM :: (a -&gt; monad monoid) -&gt; t a -&gt; monad monoid
</span><a href="Language.Haskell.TH.Desugar.Util.html#concatMapM"><span class="hs-identifier hs-var hs-var">concatMapM</span></a></span></span><span> </span><span id="local-6989586621679410844"><span class="annot"><span class="annottext">fn :: a -&gt; monad monoid
</span><a href="#local-6989586621679410844"><span class="hs-identifier hs-var">fn</span></a></span></span><span> </span><span id="local-6989586621679410843"><span class="annot"><span class="annottext">list :: t a
</span><a href="#local-6989586621679410843"><span class="hs-identifier hs-var">list</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-419"></span><span>  </span><span id="local-6989586621679410842"><span class="annot"><span class="annottext">t monoid
</span><a href="#local-6989586621679410842"><span class="hs-identifier hs-var">bss</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(a -&gt; monad monoid) -&gt; t a -&gt; monad (t monoid)
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; monad monoid
</span><a href="#local-6989586621679410844"><span class="hs-identifier hs-var">fn</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679410843"><span class="hs-identifier hs-var">list</span></a></span><span>
</span><span id="line-420"></span><span>  </span><span class="annot"><span class="annottext">monoid -&gt; monad monoid
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(monoid -&gt; monad monoid) -&gt; monoid -&gt; monad monoid
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">t monoid -&gt; monoid
forall (t :: * -&gt; *) m. (Foldable t, Monoid m) =&gt; t m -&gt; m
</span><span class="hs-identifier hs-var">fold</span></span><span> </span><span class="annot"><span class="annottext">t monoid
</span><a href="#local-6989586621679410842"><span class="hs-identifier hs-var">bss</span></a></span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span class="hs-comment">-- like GHC's</span><span>
</span><span id="line-423"></span><span class="hs-comment">-- | Monadic version of mapAccumL</span><span>
</span><span id="line-424"></span><span id="local-6989586621679411212"><span id="local-6989586621679411213"><span id="local-6989586621679411214"><span id="local-6989586621679411215"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapAccumLM"><span class="hs-identifier hs-type">mapAccumLM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679411215"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-425"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411214"><span class="hs-identifier hs-type">acc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411213"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411215"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411214"><span class="hs-identifier hs-type">acc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679411212"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ combining function</span><span>
</span><span id="line-426"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411214"><span class="hs-identifier hs-type">acc</span></a></span><span>                      </span><span class="hs-comment">-- ^ initial state</span><span>
</span><span id="line-427"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411213"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">]</span><span>                      </span><span class="hs-comment">-- ^ inputs</span><span>
</span><span id="line-428"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411215"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411214"><span class="hs-identifier hs-type">acc</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411212"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- ^ final state, outputs</span></span></span></span></span><span>
</span><span id="line-429"></span><span id="mapAccumLM"><span class="annot"><span class="annottext">mapAccumLM :: (acc -&gt; x -&gt; m (acc, y)) -&gt; acc -&gt; [x] -&gt; m (acc, [y])
</span><a href="Language.Haskell.TH.Desugar.Util.html#mapAccumLM"><span class="hs-identifier hs-var hs-var">mapAccumLM</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679410840"><span class="annot"><span class="annottext">s :: acc
</span><a href="#local-6989586621679410840"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(acc, [y]) -&gt; m (acc, [y])
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">acc
</span><a href="#local-6989586621679410840"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-430"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapAccumLM"><span class="hs-identifier hs-var">mapAccumLM</span></a></span><span> </span><span id="local-6989586621679410839"><span class="annot"><span class="annottext">f :: acc -&gt; x -&gt; m (acc, y)
</span><a href="#local-6989586621679410839"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679410838"><span class="annot"><span class="annottext">s :: acc
</span><a href="#local-6989586621679410838"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410837"><span class="annot"><span class="annottext">x :: x
</span><a href="#local-6989586621679410837"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679410836"><span class="annot"><span class="annottext">xs :: [x]
</span><a href="#local-6989586621679410836"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-431"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679410835"><span class="annot"><span class="annottext">s1 :: acc
</span><a href="#local-6989586621679410835"><span class="hs-identifier hs-var">s1</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410834"><span class="annot"><span class="annottext">x' :: y
</span><a href="#local-6989586621679410834"><span class="hs-identifier hs-var">x'</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">acc -&gt; x -&gt; m (acc, y)
</span><a href="#local-6989586621679410839"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">acc
</span><a href="#local-6989586621679410838"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679410837"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-432"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679410833"><span class="annot"><span class="annottext">s2 :: acc
</span><a href="#local-6989586621679410833"><span class="hs-identifier hs-var">s2</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679410832"><span class="annot"><span class="annottext">xs' :: [y]
</span><a href="#local-6989586621679410832"><span class="hs-identifier hs-var">xs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(acc -&gt; x -&gt; m (acc, y)) -&gt; acc -&gt; [x] -&gt; m (acc, [y])
forall (m :: * -&gt; *) acc x y.
Monad m =&gt;
(acc -&gt; x -&gt; m (acc, y)) -&gt; acc -&gt; [x] -&gt; m (acc, [y])
</span><a href="Language.Haskell.TH.Desugar.Util.html#mapAccumLM"><span class="hs-identifier hs-var">mapAccumLM</span></a></span><span> </span><span class="annot"><span class="annottext">acc -&gt; x -&gt; m (acc, y)
</span><a href="#local-6989586621679410839"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">acc
</span><a href="#local-6989586621679410835"><span class="hs-identifier hs-var">s1</span></a></span><span> </span><span class="annot"><span class="annottext">[x]
</span><a href="#local-6989586621679410836"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-433"></span><span>    </span><span class="annot"><span class="annottext">(acc, [y]) -&gt; m (acc, [y])
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">acc
</span><a href="#local-6989586621679410833"><span class="hs-identifier hs-var">s2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679410834"><span class="hs-identifier hs-var">x'</span></a></span><span> </span><span class="annot"><span class="annottext">y -&gt; [y] -&gt; [y]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[y]
</span><a href="#local-6989586621679410832"><span class="hs-identifier hs-var">xs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-434"></span><span>
</span><span id="line-435"></span><span class="hs-comment">-- like GHC's</span><span>
</span><span id="line-436"></span><span id="local-6989586621679411206"><span id="local-6989586621679411207"><span id="local-6989586621679411208"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapMaybeM"><span class="hs-identifier hs-type">mapMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679411208"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411207"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411208"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679411206"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411207"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411208"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679411206"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-437"></span><span id="mapMaybeM"><span class="annot"><span class="annottext">mapMaybeM :: (a -&gt; m (Maybe b)) -&gt; [a] -&gt; m [b]
</span><a href="Language.Haskell.TH.Desugar.Util.html#mapMaybeM"><span class="hs-identifier hs-var hs-var">mapMaybeM</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-438"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#mapMaybeM"><span class="hs-identifier hs-var">mapMaybeM</span></a></span><span> </span><span id="local-6989586621679410831"><span class="annot"><span class="annottext">f :: a -&gt; m (Maybe b)
</span><a href="#local-6989586621679410831"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679410830"><span class="annot"><span class="annottext">x :: a
</span><a href="#local-6989586621679410830"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679410829"><span class="annot"><span class="annottext">xs :: [a]
</span><a href="#local-6989586621679410829"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-439"></span><span>  </span><span id="local-6989586621679410828"><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679410828"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679410831"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679410830"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-440"></span><span>  </span><span id="local-6989586621679410827"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410827"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m [b]
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m [b]
</span><a href="Language.Haskell.TH.Desugar.Util.html#mapMaybeM"><span class="hs-identifier hs-var">mapMaybeM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679410831"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679410829"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-441"></span><span>  </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; m [b]) -&gt; [b] -&gt; m [b]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679410828"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-442"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410827"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-443"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679410826"><span class="annot"><span class="annottext">z :: b
</span><a href="#local-6989586621679410826"><span class="hs-identifier hs-var">z</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679410826"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; [b] -&gt; [b]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679410827"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-444"></span><span>
</span><span id="line-445"></span><span id="local-6989586621679410824"><span id="local-6989586621679410825"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#expectJustM"><span class="hs-identifier hs-type">expectJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679410825"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679410824"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679410825"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679410824"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-446"></span><span id="expectJustM"><span class="annot"><span class="annottext">expectJustM :: String -&gt; Maybe a -&gt; m a
</span><a href="Language.Haskell.TH.Desugar.Util.html#expectJustM"><span class="hs-identifier hs-var hs-var">expectJustM</span></a></span></span><span> </span><span class="hs-identifier">_</span><span>   </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679410823"><span class="annot"><span class="annottext">x :: a
</span><a href="#local-6989586621679410823"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679410823"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-447"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#expectJustM"><span class="hs-identifier hs-var">expectJustM</span></a></span><span> </span><span id="local-6989586621679410822"><span class="annot"><span class="annottext">err :: String
</span><a href="#local-6989586621679410822"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">Fail.fail</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679410822"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-448"></span><span>
</span><span id="line-449"></span><span id="local-6989586621679410820"><span id="local-6989586621679410821"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#firstMatch"><span class="hs-identifier hs-type">firstMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679410821"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679410820"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679410821"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679410820"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-450"></span><span id="firstMatch"><span class="annot"><span class="annottext">firstMatch :: (a -&gt; Maybe b) -&gt; [a] -&gt; Maybe b
</span><a href="Language.Haskell.TH.Desugar.Util.html#firstMatch"><span class="hs-identifier hs-var hs-var">firstMatch</span></a></span></span><span> </span><span id="local-6989586621679410819"><span class="annot"><span class="annottext">f :: a -&gt; Maybe b
</span><a href="#local-6989586621679410819"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679410818"><span class="annot"><span class="annottext">xs :: [a]
</span><a href="#local-6989586621679410818"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; Maybe b
forall a. [a] -&gt; Maybe a
</span><span class="hs-identifier hs-var">listToMaybe</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; Maybe b) -&gt; [b] -&gt; Maybe b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe b) -&gt; [a] -&gt; [b]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe b
</span><a href="#local-6989586621679410819"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679410818"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-451"></span><span>
</span><span id="line-452"></span><span class="hs-comment">-- | Semi-shallow version of 'everywhereM' - does not recurse into children of nodes of type @a@ (only applies the handler to them).</span><span>
</span><span id="line-453"></span><span class="hs-comment">--</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- &gt;&gt;&gt; topEverywhereM (pure . fmap (*10) :: [Integer] -&gt; Identity [Integer]) ([1,2,3] :: [Integer], &quot;foo&quot; :: String)</span><span>
</span><span id="line-455"></span><span class="hs-comment">-- Identity ([10,20,30],&quot;foo&quot;)</span><span>
</span><span id="line-456"></span><span class="hs-comment">--</span><span>
</span><span id="line-457"></span><span class="hs-comment">-- &gt;&gt;&gt; everywhereM (mkM (pure . fmap (*10) :: [Integer] -&gt; Identity [Integer])) ([1,2,3] :: [Integer], &quot;foo&quot; :: String)</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- Identity ([10,200,3000],&quot;foo&quot;)</span><span>
</span><span id="line-459"></span><span id="local-6989586621679411194"><span id="local-6989586621679411195"><span id="local-6989586621679411196"><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#topEverywhereM"><span class="hs-identifier hs-type">topEverywhereM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621679411196"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data</span></span><span> </span><span class="annot"><a href="#local-6989586621679411195"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679411194"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679411196"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679411196"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411195"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679411194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679411195"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-460"></span><span id="topEverywhereM"><span class="annot"><span class="annottext">topEverywhereM :: (a -&gt; m a) -&gt; b -&gt; m b
</span><a href="Language.Haskell.TH.Desugar.Util.html#topEverywhereM"><span class="hs-identifier hs-var hs-var">topEverywhereM</span></a></span></span><span> </span><span id="local-6989586621679410816"><span class="annot"><span class="annottext">handler :: a -&gt; m a
</span><a href="#local-6989586621679410816"><span class="hs-identifier hs-var">handler</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-461"></span><span>  </span><span class="annot"><span class="annottext">(forall d. Data d =&gt; d -&gt; m d) -&gt; b -&gt; m b
forall a (m :: * -&gt; *).
(Data a, Monad m) =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">gmapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; m a) -&gt; d -&gt; m d
forall a b (m :: * -&gt; *).
(Typeable a, Data b, Monad m) =&gt;
(a -&gt; m a) -&gt; b -&gt; m b
</span><a href="Language.Haskell.TH.Desugar.Util.html#topEverywhereM"><span class="hs-identifier hs-var">topEverywhereM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679410816"><span class="hs-identifier hs-var">handler</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(b -&gt; m b) -&gt; (a -&gt; m a) -&gt; b -&gt; m b
forall (m :: * -&gt; *) a b.
(Monad m, Typeable a, Typeable b) =&gt;
(a -&gt; m a) -&gt; (b -&gt; m b) -&gt; a -&gt; m a
</span><span class="hs-operator hs-var">`extM`</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679410816"><span class="hs-identifier hs-var">handler</span></a></span><span>
</span><span id="line-462"></span><span>
</span><span id="line-463"></span><span class="hs-comment">-- Checks if a String names a valid Haskell infix data constructor</span><span>
</span><span id="line-464"></span><span class="hs-comment">-- (i.e., does it begin with a colon?).</span><span>
</span><span id="line-465"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isInfixDataCon"><span class="hs-identifier hs-type">isInfixDataCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-466"></span><span id="isInfixDataCon"><span class="annot"><span class="annottext">isInfixDataCon :: String -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.Util.html#isInfixDataCon"><span class="hs-identifier hs-var hs-var">isInfixDataCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-char">':'</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-467"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isInfixDataCon"><span class="hs-identifier hs-var">isInfixDataCon</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-468"></span><span>
</span><span id="line-469"></span><span class="hs-comment">-- | Returns 'True' if the argument 'Name' is that of 'Kind.Type'</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- (or @*@ or 'Kind.&#9733;', to support older GHCs).</span><span>
</span><span id="line-471"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#isTypeKindName"><span class="hs-identifier hs-type">isTypeKindName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-472"></span><span id="isTypeKindName"><span class="annot"><span class="annottext">isTypeKindName :: Name -&gt; Bool
</span><a href="Language.Haskell.TH.Desugar.Util.html#isTypeKindName"><span class="hs-identifier hs-var hs-var">isTypeKindName</span></a></span></span><span> </span><span id="local-6989586621679410813"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679410813"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679410813"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#typeKindName"><span class="hs-identifier hs-var">typeKindName</span></a></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 805
</span><span>                </span><span class="hs-operator">||</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">starKindName</span><span>
</span><span id="line-475"></span><span>                </span><span class="hs-operator">||</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">uniStarKindName</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-478"></span><span class="hs-comment">-- | The 'Name' of:</span><span>
</span><span id="line-479"></span><span class="hs-comment">--</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- 1. The kind 'Kind.Type', on GHC 8.0 or later.</span><span>
</span><span id="line-481"></span><span class="hs-comment">-- 2. The kind @*@ on older GHCs.</span><span>
</span><span id="line-482"></span><span class="annot"><a href="Language.Haskell.TH.Desugar.Util.html#typeKindName"><span class="hs-identifier hs-type">typeKindName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span id="typeKindName"><span class="annot"><span class="annottext">typeKindName :: Name
</span><a href="Language.Haskell.TH.Desugar.Util.html#typeKindName"><span class="hs-identifier hs-var hs-var">typeKindName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Kind.Type</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">typeKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">starKindName</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 805
</span><span class="hs-comment">-- | The 'Name' of the kind @*@.</span><span>
</span><span id="line-491"></span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Name</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">''</span><span class="hs-special">(</span><span class="hs-operator">Kind.*</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">mkNameG_tc</span><span> </span><span class="hs-string">&quot;ghc-prim&quot;</span><span> </span><span class="hs-string">&quot;GHC.Prim&quot;</span><span> </span><span class="hs-string">&quot;*&quot;</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-498"></span><span class="hs-comment">-- | The 'Name' of:</span><span>
</span><span id="line-499"></span><span class="hs-comment">--</span><span>
</span><span id="line-500"></span><span class="hs-comment">-- 1. The kind 'Kind.&#9733;', on GHC 8.0 or later.</span><span>
</span><span id="line-501"></span><span class="hs-comment">-- 2. The kind @*@ on older GHCs.</span><span>
</span><span id="line-502"></span><span class="hs-identifier">uniStarKindName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Name</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span class="hs-identifier">uniStarKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">''</span><span class="hs-special">(</span><span class="hs-operator">Kind.&#9733;</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">uniStarKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">starKindName</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#endif
</span></pre></body></html>